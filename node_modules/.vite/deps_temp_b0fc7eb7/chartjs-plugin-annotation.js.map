{
  "version": 3,
  "sources": ["../../chartjs-plugin-annotation/dist/chartjs-plugin-annotation.esm.js"],
  "sourcesContent": ["/*!\r\n* chartjs-plugin-annotation v3.0.1\r\n* https://www.chartjs.org/chartjs-plugin-annotation/index\r\n * (c) 2023 chartjs-plugin-annotation Contributors\r\n * Released under the MIT License\r\n */\r\nimport { Element, defaults, Animations, Chart } from 'chart.js';\r\nimport { distanceBetweenPoints, defined, isFunction, callback, isObject, valueOrDefault, toRadians, isArray, toFont, addRoundedRectPath, toTRBLCorners, QUARTER_PI, PI, HALF_PI, TWO_THIRDS_PI, TAU, isNumber, RAD_PER_DEG, toPadding, isFinite, toDegrees, clipArea, unclipArea } from 'chart.js/helpers';\r\n\r\n/**\r\n * @typedef { import(\"chart.js\").ChartEvent } ChartEvent\r\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\r\n */\r\n\r\nconst interaction = {\r\n  modes: {\r\n    /**\r\n     * Point mode returns all elements that hit test based on the event position\r\n     * @param {Object} state - the state of the plugin\r\n     * @param {ChartEvent} event - the event we are find things at\r\n     * @return {AnnotationElement[]} - elements that are found\r\n     */\r\n    point(state, event) {\r\n      return filterElements(state, event, {intersect: true});\r\n    },\r\n\r\n    /**\r\n     * Nearest mode returns the element closest to the event position\r\n     * @param {Object} state - the state of the plugin\r\n     * @param {ChartEvent} event - the event we are find things at\r\n     * @param {Object} options - interaction options to use\r\n     * @return {AnnotationElement[]} - elements that are found (only 1 element)\r\n     */\r\n    nearest(state, event, options) {\r\n      return getNearestItem(state, event, options);\r\n    },\r\n    /**\r\n     * x mode returns the elements that hit-test at the current x coordinate\r\n     * @param {Object} state - the state of the plugin\r\n     * @param {ChartEvent} event - the event we are find things at\r\n     * @param {Object} options - interaction options to use\r\n     * @return {AnnotationElement[]} - elements that are found\r\n     */\r\n    x(state, event, options) {\r\n      return filterElements(state, event, {intersect: options.intersect, axis: 'x'});\r\n    },\r\n\r\n    /**\r\n     * y mode returns the elements that hit-test at the current y coordinate\r\n     * @param {Object} state - the state of the plugin\r\n     * @param {ChartEvent} event - the event we are find things at\r\n     * @param {Object} options - interaction options to use\r\n     * @return {AnnotationElement[]} - elements that are found\r\n     */\r\n    y(state, event, options) {\r\n      return filterElements(state, event, {intersect: options.intersect, axis: 'y'});\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Returns all elements that hit test based on the event position\r\n * @param {Object} state - the state of the plugin\r\n * @param {ChartEvent} event - the event we are find things at\r\n * @param {Object} options - interaction options to use\r\n * @return {AnnotationElement[]} - elements that are found\r\n */\r\nfunction getElements(state, event, options) {\r\n  const mode = interaction.modes[options.mode] || interaction.modes.nearest;\r\n  return mode(state, event, options);\r\n}\r\n\r\nfunction inRangeByAxis(element, event, axis) {\r\n  if (axis !== 'x' && axis !== 'y') {\r\n    return element.inRange(event.x, event.y, 'x', true) || element.inRange(event.x, event.y, 'y', true);\r\n  }\r\n  return element.inRange(event.x, event.y, axis, true);\r\n}\r\n\r\nfunction getPointByAxis(event, center, axis) {\r\n  if (axis === 'x') {\r\n    return {x: event.x, y: center.y};\r\n  } else if (axis === 'y') {\r\n    return {x: center.x, y: event.y};\r\n  }\r\n  return center;\r\n}\r\n\r\nfunction filterElements(state, event, options) {\r\n  return state.visibleElements.filter((element) => options.intersect ? element.inRange(event.x, event.y) : inRangeByAxis(element, event, options.axis));\r\n}\r\n\r\nfunction getNearestItem(state, event, options) {\r\n  let minDistance = Number.POSITIVE_INFINITY;\r\n\r\n  return filterElements(state, event, options)\r\n    .reduce((nearestItems, element) => {\r\n      const center = element.getCenterPoint();\r\n      const evenPoint = getPointByAxis(event, center, options.axis);\r\n      const distance = distanceBetweenPoints(event, evenPoint);\r\n      if (distance < minDistance) {\r\n        nearestItems = [element];\r\n        minDistance = distance;\r\n      } else if (distance === minDistance) {\r\n        // Can have multiple items at the same distance in which case we sort by size\r\n        nearestItems.push(element);\r\n      }\r\n\r\n      return nearestItems;\r\n    }, [])\r\n    .sort((a, b) => a._index - b._index)\r\n    .slice(0, 1); // return only the top item;\r\n}\r\n\r\nconst isOlderPart = (act, req) => req > act || (act.length > req.length && act.slice(0, req.length) === req);\r\n\r\n/**\r\n * @typedef { import('chart.js').Point } Point\r\n * @typedef { import('chart.js').InteractionAxis } InteractionAxis\r\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\r\n */\r\n\r\nconst EPSILON = 0.001;\r\nconst clamp = (x, from, to) => Math.min(to, Math.max(from, x));\r\n\r\n/**\r\n * @param {Object} obj\r\n * @param {number} from\r\n * @param {number} to\r\n * @returns {Object}\r\n */\r\nfunction clampAll(obj, from, to) {\r\n  for (const key of Object.keys(obj)) {\r\n    obj[key] = clamp(obj[key], from, to);\r\n  }\r\n  return obj;\r\n}\r\n\r\n/**\r\n * @param {Point} point\r\n * @param {Point} center\r\n * @param {number} radius\r\n * @param {number} borderWidth\r\n * @returns {boolean}\r\n */\r\nfunction inPointRange(point, center, radius, borderWidth) {\r\n  if (!point || !center || radius <= 0) {\r\n    return false;\r\n  }\r\n  const hBorderWidth = borderWidth / 2;\r\n  return (Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2)) <= Math.pow(radius + hBorderWidth, 2);\r\n}\r\n\r\n/**\r\n * @param {Point} point\r\n * @param {{x: number, y: number, x2: number, y2: number}} rect\r\n * @param {InteractionAxis} axis\r\n * @param {number} borderWidth\r\n * @returns {boolean}\r\n */\r\nfunction inBoxRange(point, {x, y, x2, y2}, axis, borderWidth) {\r\n  const hBorderWidth = borderWidth / 2;\r\n  const inRangeX = point.x >= x - hBorderWidth - EPSILON && point.x <= x2 + hBorderWidth + EPSILON;\r\n  const inRangeY = point.y >= y - hBorderWidth - EPSILON && point.y <= y2 + hBorderWidth + EPSILON;\r\n  if (axis === 'x') {\r\n    return inRangeX;\r\n  } else if (axis === 'y') {\r\n    return inRangeY;\r\n  }\r\n  return inRangeX && inRangeY;\r\n}\r\n\r\n/**\r\n * @param {AnnotationElement} element\r\n * @param {boolean} useFinalPosition\r\n * @returns {Point}\r\n */\r\nfunction getElementCenterPoint(element, useFinalPosition) {\r\n  const {centerX, centerY} = element.getProps(['centerX', 'centerY'], useFinalPosition);\r\n  return {x: centerX, y: centerY};\r\n}\r\n\r\n/**\r\n * @param {string} pkg\r\n * @param {string} min\r\n * @param {string} ver\r\n * @param {boolean} [strict=true]\r\n * @returns {boolean}\r\n */\r\nfunction requireVersion(pkg, min, ver, strict = true) {\r\n  const parts = ver.split('.');\r\n  let i = 0;\r\n  for (const req of min.split('.')) {\r\n    const act = parts[i++];\r\n    if (parseInt(req, 10) < parseInt(act, 10)) {\r\n      break;\r\n    }\r\n    if (isOlderPart(act, req)) {\r\n      if (strict) {\r\n        throw new Error(`${pkg} v${ver} is not supported. v${min} or newer is required.`);\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nconst isPercentString = (s) => typeof s === 'string' && s.endsWith('%');\r\nconst toPercent = (s) => parseFloat(s) / 100;\r\nconst toPositivePercent = (s) => clamp(toPercent(s), 0, 1);\r\n\r\nconst boxAppering = (x, y) => ({x, y, x2: x, y2: y, width: 0, height: 0});\r\nconst defaultInitAnimation = {\r\n  box: (properties) => boxAppering(properties.centerX, properties.centerY),\r\n  ellipse: (properties) => ({centerX: properties.centerX, centerY: properties.centerX, radius: 0, width: 0, height: 0}),\r\n  label: (properties) => boxAppering(properties.centerX, properties.centerY),\r\n  line: (properties) => boxAppering(properties.x, properties.y),\r\n  point: (properties) => ({centerX: properties.centerX, centerY: properties.centerY, radius: 0, width: 0, height: 0}),\r\n  polygon: (properties) => boxAppering(properties.centerX, properties.centerY)\r\n};\r\n\r\n/**\r\n * @typedef { import(\"chart.js\").Chart } Chart\r\n * @typedef { import('../../types/element').AnnotationBoxModel } AnnotationBoxModel\r\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\r\n * @typedef { import('../../types/options').AnnotationPointCoordinates } AnnotationPointCoordinates\r\n * @typedef { import('../../types/label').CoreLabelOptions } CoreLabelOptions\r\n * @typedef { import('../../types/label').LabelPositionObject } LabelPositionObject\r\n */\r\n\r\n/**\r\n * @param {number} size\r\n * @param {number|string} position\r\n * @returns {number}\r\n */\r\nfunction getRelativePosition(size, position) {\r\n  if (position === 'start') {\r\n    return 0;\r\n  }\r\n  if (position === 'end') {\r\n    return size;\r\n  }\r\n  if (isPercentString(position)) {\r\n    return toPositivePercent(position) * size;\r\n  }\r\n  return size / 2;\r\n}\r\n\r\n/**\r\n * @param {number} size\r\n * @param {number|string} value\r\n * @param {boolean} [positivePercent=true]\r\n * @returns {number}\r\n */\r\nfunction getSize(size, value, positivePercent = true) {\r\n  if (typeof value === 'number') {\r\n    return value;\r\n  } else if (isPercentString(value)) {\r\n    return (positivePercent ? toPositivePercent(value) : toPercent(value)) * size;\r\n  }\r\n  return size;\r\n}\r\n\r\n/**\r\n * @param {{x: number, width: number}} size\r\n * @param {CoreLabelOptions} options\r\n * @returns {number}\r\n */\r\nfunction calculateTextAlignment(size, options) {\r\n  const {x, width} = size;\r\n  const textAlign = options.textAlign;\r\n  if (textAlign === 'center') {\r\n    return x + width / 2;\r\n  } else if (textAlign === 'end' || textAlign === 'right') {\r\n    return x + width;\r\n  }\r\n  return x;\r\n}\r\n\r\n/**\r\n * @param {{x: number|string, y: number|string}|string|number} value\r\n * @param {string|number} defaultValue\r\n * @returns {{x: number|string, y: number|string}}\r\n */\r\nfunction toPosition(value, defaultValue = 'center') {\r\n  if (isObject(value)) {\r\n    return {\r\n      x: valueOrDefault(value.x, defaultValue),\r\n      y: valueOrDefault(value.y, defaultValue),\r\n    };\r\n  }\r\n  value = valueOrDefault(value, defaultValue);\r\n  return {\r\n    x: value,\r\n    y: value\r\n  };\r\n}\r\n\r\n/**\r\n * @param {AnnotationPointCoordinates} options\r\n * @returns {boolean}\r\n */\r\nfunction isBoundToPoint(options) {\r\n  return options && (defined(options.xValue) || defined(options.yValue));\r\n}\r\n\r\n/**\r\n * @param {Chart} chart\r\n * @param {AnnotationBoxModel} properties\r\n * @param {CoreAnnotationOptions} options\r\n * @returns {AnnotationElement}\r\n */\r\nfunction initAnimationProperties(chart, properties, options) {\r\n  const initAnim = options.init;\r\n  if (!initAnim) {\r\n    return;\r\n  } else if (initAnim === true) {\r\n    return applyDefault(properties, options);\r\n  }\r\n  return execCallback(chart, properties, options);\r\n}\r\n\r\n/**\r\n * @param {Object} options\r\n * @param {Array} hooks\r\n * @param {Object} hooksContainer\r\n * @returns {boolean}\r\n */\r\nfunction loadHooks(options, hooks, hooksContainer) {\r\n  let activated = false;\r\n  hooks.forEach(hook => {\r\n    if (isFunction(options[hook])) {\r\n      activated = true;\r\n      hooksContainer[hook] = options[hook];\r\n    } else if (defined(hooksContainer[hook])) {\r\n      delete hooksContainer[hook];\r\n    }\r\n  });\r\n  return activated;\r\n}\r\n\r\nfunction applyDefault(properties, options) {\r\n  const type = options.type || 'line';\r\n  return defaultInitAnimation[type](properties);\r\n}\r\n\r\nfunction execCallback(chart, properties, options) {\r\n  const result = callback(options.init, [{chart, properties, options}]);\r\n  if (result === true) {\r\n    return applyDefault(properties, options);\r\n  } else if (isObject(result)) {\r\n    return result;\r\n  }\r\n}\r\n\r\nconst widthCache = new Map();\r\nconst notRadius = (radius) => isNaN(radius) || radius <= 0;\r\nconst fontsKey = (fonts) => fonts.reduce(function(prev, item) {\r\n  prev += item.string;\r\n  return prev;\r\n}, '');\r\n\r\n/**\r\n * @typedef { import('chart.js').Point } Point\r\n * @typedef { import('../../types/label').CoreLabelOptions } CoreLabelOptions\r\n * @typedef { import('../../types/options').PointAnnotationOptions } PointAnnotationOptions\r\n */\r\n\r\n/**\r\n * Determine if content is an image or a canvas.\r\n * @param {*} content\r\n * @returns boolean|undefined\r\n * @todo move this function to chart.js helpers\r\n */\r\nfunction isImageOrCanvas(content) {\r\n  if (content && typeof content === 'object') {\r\n    const type = content.toString();\r\n    return (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]');\r\n  }\r\n}\r\n\r\n/**\r\n * Set the translation on the canvas if the rotation must be applied.\r\n * @param {CanvasRenderingContext2D} ctx - chart canvas context\r\n * @param {Point} point - the point of translation\r\n * @param {number} rotation - rotation (in degrees) to apply\r\n */\r\nfunction translate(ctx, {x, y}, rotation) {\r\n  if (rotation) {\r\n    ctx.translate(x, y);\r\n    ctx.rotate(toRadians(rotation));\r\n    ctx.translate(-x, -y);\r\n  }\r\n}\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {Object} options\r\n * @returns {boolean|undefined}\r\n */\r\nfunction setBorderStyle(ctx, options) {\r\n  if (options && options.borderWidth) {\r\n    ctx.lineCap = options.borderCapStyle;\r\n    ctx.setLineDash(options.borderDash);\r\n    ctx.lineDashOffset = options.borderDashOffset;\r\n    ctx.lineJoin = options.borderJoinStyle;\r\n    ctx.lineWidth = options.borderWidth;\r\n    ctx.strokeStyle = options.borderColor;\r\n    return true;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {Object} options\r\n */\r\nfunction setShadowStyle(ctx, options) {\r\n  ctx.shadowColor = options.backgroundShadowColor;\r\n  ctx.shadowBlur = options.shadowBlur;\r\n  ctx.shadowOffsetX = options.shadowOffsetX;\r\n  ctx.shadowOffsetY = options.shadowOffsetY;\r\n}\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {CoreLabelOptions} options\r\n * @returns {{width: number, height: number}}\r\n */\r\nfunction measureLabelSize(ctx, options) {\r\n  const content = options.content;\r\n  if (isImageOrCanvas(content)) {\r\n    return {\r\n      width: getSize(content.width, options.width),\r\n      height: getSize(content.height, options.height)\r\n    };\r\n  }\r\n  const optFont = options.font;\r\n  const fonts = isArray(optFont) ? optFont.map(f => toFont(f)) : [toFont(optFont)];\r\n  const strokeWidth = options.textStrokeWidth;\r\n  const lines = isArray(content) ? content : [content];\r\n  const mapKey = lines.join() + fontsKey(fonts) + strokeWidth + (ctx._measureText ? '-spriting' : '');\r\n  if (!widthCache.has(mapKey)) {\r\n    widthCache.set(mapKey, calculateLabelSize(ctx, lines, fonts, strokeWidth));\r\n  }\r\n  return widthCache.get(mapKey);\r\n}\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {{x: number, y: number, width: number, height: number}} rect\r\n * @param {Object} options\r\n */\r\nfunction drawBox(ctx, rect, options) {\r\n  const {x, y, width, height} = rect;\r\n  ctx.save();\r\n  setShadowStyle(ctx, options);\r\n  const stroke = setBorderStyle(ctx, options);\r\n  ctx.fillStyle = options.backgroundColor;\r\n  ctx.beginPath();\r\n  addRoundedRectPath(ctx, {\r\n    x, y, w: width, h: height,\r\n    radius: clampAll(toTRBLCorners(options.borderRadius), 0, Math.min(width, height) / 2)\r\n  });\r\n  ctx.closePath();\r\n  ctx.fill();\r\n  if (stroke) {\r\n    ctx.shadowColor = options.borderShadowColor;\r\n    ctx.stroke();\r\n  }\r\n  ctx.restore();\r\n}\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {{x: number, y: number, width: number, height: number}} rect\r\n * @param {CoreLabelOptions} options\r\n */\r\nfunction drawLabel(ctx, rect, options) {\r\n  const content = options.content;\r\n  if (isImageOrCanvas(content)) {\r\n    ctx.save();\r\n    ctx.globalAlpha = getOpacity(options.opacity, content.style.opacity);\r\n    ctx.drawImage(content, rect.x, rect.y, rect.width, rect.height);\r\n    ctx.restore();\r\n    return;\r\n  }\r\n  const labels = isArray(content) ? content : [content];\r\n  const optFont = options.font;\r\n  const fonts = isArray(optFont) ? optFont.map(f => toFont(f)) : [toFont(optFont)];\r\n  const optColor = options.color;\r\n  const colors = isArray(optColor) ? optColor : [optColor];\r\n  const x = calculateTextAlignment(rect, options);\r\n  const y = rect.y + options.textStrokeWidth / 2;\r\n  ctx.save();\r\n  ctx.textBaseline = 'middle';\r\n  ctx.textAlign = options.textAlign;\r\n  if (setTextStrokeStyle(ctx, options)) {\r\n    applyLabelDecoration(ctx, {x, y}, labels, fonts);\r\n  }\r\n  applyLabelContent(ctx, {x, y}, labels, {fonts, colors});\r\n  ctx.restore();\r\n}\r\n\r\nfunction setTextStrokeStyle(ctx, options) {\r\n  if (options.textStrokeWidth > 0) {\r\n    // https://stackoverflow.com/questions/13627111/drawing-text-with-an-outer-stroke-with-html5s-canvas\r\n    ctx.lineJoin = 'round';\r\n    ctx.miterLimit = 2;\r\n    ctx.lineWidth = options.textStrokeWidth;\r\n    ctx.strokeStyle = options.textStrokeColor;\r\n    return true;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {{radius: number, options: PointAnnotationOptions}} element\r\n * @param {number} x\r\n * @param {number} y\r\n */\r\nfunction drawPoint(ctx, element, x, y) {\r\n  const {radius, options} = element;\r\n  const style = options.pointStyle;\r\n  const rotation = options.rotation;\r\n  let rad = (rotation || 0) * RAD_PER_DEG;\r\n\r\n  if (isImageOrCanvas(style)) {\r\n    ctx.save();\r\n    ctx.translate(x, y);\r\n    ctx.rotate(rad);\r\n    ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\r\n    ctx.restore();\r\n    return;\r\n  }\r\n  if (notRadius(radius)) {\r\n    return;\r\n  }\r\n  drawPointStyle(ctx, {x, y, radius, rotation, style, rad});\r\n}\r\n\r\nfunction drawPointStyle(ctx, {x, y, radius, rotation, style, rad}) {\r\n  let xOffset, yOffset, size, cornerRadius;\r\n  ctx.beginPath();\r\n\r\n  switch (style) {\r\n  // Default includes circle\r\n  default:\r\n    ctx.arc(x, y, radius, 0, TAU);\r\n    ctx.closePath();\r\n    break;\r\n  case 'triangle':\r\n    ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\r\n    rad += TWO_THIRDS_PI;\r\n    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\r\n    rad += TWO_THIRDS_PI;\r\n    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\r\n    ctx.closePath();\r\n    break;\r\n  case 'rectRounded':\r\n    // NOTE: the rounded rect implementation changed to use `arc` instead of\r\n    // `quadraticCurveTo` since it generates better results when rect is\r\n    // almost a circle. 0.516 (instead of 0.5) produces results with visually\r\n    // closer proportion to the previous impl and it is inscribed in the\r\n    // circle with `radius`. For more details, see the following PRs:\r\n    // https://github.com/chartjs/Chart.js/issues/5597\r\n    // https://github.com/chartjs/Chart.js/issues/5858\r\n    cornerRadius = radius * 0.516;\r\n    size = radius - cornerRadius;\r\n    xOffset = Math.cos(rad + QUARTER_PI) * size;\r\n    yOffset = Math.sin(rad + QUARTER_PI) * size;\r\n    ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\r\n    ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);\r\n    ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);\r\n    ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\r\n    ctx.closePath();\r\n    break;\r\n  case 'rect':\r\n    if (!rotation) {\r\n      size = Math.SQRT1_2 * radius;\r\n      ctx.rect(x - size, y - size, 2 * size, 2 * size);\r\n      break;\r\n    }\r\n    rad += QUARTER_PI;\r\n    /* falls through */\r\n  case 'rectRot':\r\n    xOffset = Math.cos(rad) * radius;\r\n    yOffset = Math.sin(rad) * radius;\r\n    ctx.moveTo(x - xOffset, y - yOffset);\r\n    ctx.lineTo(x + yOffset, y - xOffset);\r\n    ctx.lineTo(x + xOffset, y + yOffset);\r\n    ctx.lineTo(x - yOffset, y + xOffset);\r\n    ctx.closePath();\r\n    break;\r\n  case 'crossRot':\r\n    rad += QUARTER_PI;\r\n    /* falls through */\r\n  case 'cross':\r\n    xOffset = Math.cos(rad) * radius;\r\n    yOffset = Math.sin(rad) * radius;\r\n    ctx.moveTo(x - xOffset, y - yOffset);\r\n    ctx.lineTo(x + xOffset, y + yOffset);\r\n    ctx.moveTo(x + yOffset, y - xOffset);\r\n    ctx.lineTo(x - yOffset, y + xOffset);\r\n    break;\r\n  case 'star':\r\n    xOffset = Math.cos(rad) * radius;\r\n    yOffset = Math.sin(rad) * radius;\r\n    ctx.moveTo(x - xOffset, y - yOffset);\r\n    ctx.lineTo(x + xOffset, y + yOffset);\r\n    ctx.moveTo(x + yOffset, y - xOffset);\r\n    ctx.lineTo(x - yOffset, y + xOffset);\r\n    rad += QUARTER_PI;\r\n    xOffset = Math.cos(rad) * radius;\r\n    yOffset = Math.sin(rad) * radius;\r\n    ctx.moveTo(x - xOffset, y - yOffset);\r\n    ctx.lineTo(x + xOffset, y + yOffset);\r\n    ctx.moveTo(x + yOffset, y - xOffset);\r\n    ctx.lineTo(x - yOffset, y + xOffset);\r\n    break;\r\n  case 'line':\r\n    xOffset = Math.cos(rad) * radius;\r\n    yOffset = Math.sin(rad) * radius;\r\n    ctx.moveTo(x - xOffset, y - yOffset);\r\n    ctx.lineTo(x + xOffset, y + yOffset);\r\n    break;\r\n  case 'dash':\r\n    ctx.moveTo(x, y);\r\n    ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);\r\n    break;\r\n  }\r\n\r\n  ctx.fill();\r\n}\r\n\r\nfunction calculateLabelSize(ctx, lines, fonts, strokeWidth) {\r\n  ctx.save();\r\n  const count = lines.length;\r\n  let width = 0;\r\n  let height = strokeWidth;\r\n  for (let i = 0; i < count; i++) {\r\n    const font = fonts[Math.min(i, fonts.length - 1)];\r\n    ctx.font = font.string;\r\n    const text = lines[i];\r\n    width = Math.max(width, ctx.measureText(text).width + strokeWidth);\r\n    height += font.lineHeight;\r\n  }\r\n  ctx.restore();\r\n  return {width, height};\r\n}\r\n\r\nfunction applyLabelDecoration(ctx, {x, y}, labels, fonts) {\r\n  ctx.beginPath();\r\n  let lhs = 0;\r\n  labels.forEach(function(l, i) {\r\n    const f = fonts[Math.min(i, fonts.length - 1)];\r\n    const lh = f.lineHeight;\r\n    ctx.font = f.string;\r\n    ctx.strokeText(l, x, y + lh / 2 + lhs);\r\n    lhs += lh;\r\n  });\r\n  ctx.stroke();\r\n}\r\n\r\nfunction applyLabelContent(ctx, {x, y}, labels, {fonts, colors}) {\r\n  let lhs = 0;\r\n  labels.forEach(function(l, i) {\r\n    const c = colors[Math.min(i, colors.length - 1)];\r\n    const f = fonts[Math.min(i, fonts.length - 1)];\r\n    const lh = f.lineHeight;\r\n    ctx.beginPath();\r\n    ctx.font = f.string;\r\n    ctx.fillStyle = c;\r\n    ctx.fillText(l, x, y + lh / 2 + lhs);\r\n    lhs += lh;\r\n    ctx.fill();\r\n  });\r\n}\r\n\r\nfunction getOpacity(value, elementValue) {\r\n  const opacity = isNumber(value) ? value : elementValue;\r\n  return isNumber(opacity) ? clamp(opacity, 0, 1) : 1;\r\n}\r\n\r\nconst limitedLineScale = {\r\n  xScaleID: {min: 'xMin', max: 'xMax', start: 'left', end: 'right', startProp: 'x', endProp: 'x2'},\r\n  yScaleID: {min: 'yMin', max: 'yMax', start: 'bottom', end: 'top', startProp: 'y', endProp: 'y2'}\r\n};\r\n\r\n/**\r\n * @typedef { import(\"chart.js\").Chart } Chart\r\n * @typedef { import(\"chart.js\").Scale } Scale\r\n * @typedef { import(\"chart.js\").Point } Point\r\n * @typedef { import('../../types/element').AnnotationBoxModel } AnnotationBoxModel\r\n * @typedef { import('../../types/options').CoreAnnotationOptions } CoreAnnotationOptions\r\n * @typedef { import('../../types/options').LineAnnotationOptions } LineAnnotationOptions\r\n * @typedef { import('../../types/options').PointAnnotationOptions } PointAnnotationOptions\r\n * @typedef { import('../../types/options').PolygonAnnotationOptions } PolygonAnnotationOptions\r\n */\r\n\r\n/**\r\n * @param {Scale} scale\r\n * @param {number|string} value\r\n * @param {number} fallback\r\n * @returns {number}\r\n */\r\nfunction scaleValue(scale, value, fallback) {\r\n  value = typeof value === 'number' ? value : scale.parse(value);\r\n  return isFinite(value) ? scale.getPixelForValue(value) : fallback;\r\n}\r\n\r\n/**\r\n * Search the scale defined in chartjs by the axis related to the annotation options key.\r\n * @param {{ [key: string]: Scale }} scales\r\n * @param {CoreAnnotationOptions} options\r\n * @param {string} key\r\n * @returns {string}\r\n */\r\nfunction retrieveScaleID(scales, options, key) {\r\n  const scaleID = options[key];\r\n  if (scaleID || key === 'scaleID') {\r\n    return scaleID;\r\n  }\r\n  const axis = key.charAt(0);\r\n  const axes = Object.values(scales).filter((scale) => scale.axis && scale.axis === axis);\r\n  if (axes.length) {\r\n    return axes[0].id;\r\n  }\r\n  return axis;\r\n}\r\n\r\n/**\r\n * @param {Scale} scale\r\n * @param {{min: number, max: number, start: number, end: number}} options\r\n * @returns {{start: number, end: number}|undefined}\r\n */\r\nfunction getDimensionByScale(scale, options) {\r\n  if (scale) {\r\n    const reverse = scale.options.reverse;\r\n    const start = scaleValue(scale, options.min, reverse ? options.end : options.start);\r\n    const end = scaleValue(scale, options.max, reverse ? options.start : options.end);\r\n    return {\r\n      start,\r\n      end\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Chart} chart\r\n * @param {CoreAnnotationOptions} options\r\n * @returns {Point}\r\n */\r\nfunction getChartPoint(chart, options) {\r\n  const {chartArea, scales} = chart;\r\n  const xScale = scales[retrieveScaleID(scales, options, 'xScaleID')];\r\n  const yScale = scales[retrieveScaleID(scales, options, 'yScaleID')];\r\n  let x = chartArea.width / 2;\r\n  let y = chartArea.height / 2;\r\n\r\n  if (xScale) {\r\n    x = scaleValue(xScale, options.xValue, xScale.left + xScale.width / 2);\r\n  }\r\n\r\n  if (yScale) {\r\n    y = scaleValue(yScale, options.yValue, yScale.top + yScale.height / 2);\r\n  }\r\n  return {x, y};\r\n}\r\n\r\n/**\r\n * @param {Chart} chart\r\n * @param {CoreAnnotationOptions} options\r\n * @returns {AnnotationBoxModel}\r\n */\r\nfunction resolveBoxProperties(chart, options) {\r\n  const scales = chart.scales;\r\n  const xScale = scales[retrieveScaleID(scales, options, 'xScaleID')];\r\n  const yScale = scales[retrieveScaleID(scales, options, 'yScaleID')];\r\n\r\n  if (!xScale && !yScale) {\r\n    return {};\r\n  }\r\n\r\n  let {left: x, right: x2} = xScale || chart.chartArea;\r\n  let {top: y, bottom: y2} = yScale || chart.chartArea;\r\n  const xDim = getChartDimensionByScale(xScale, {min: options.xMin, max: options.xMax, start: x, end: x2});\r\n  x = xDim.start;\r\n  x2 = xDim.end;\r\n  const yDim = getChartDimensionByScale(yScale, {min: options.yMin, max: options.yMax, start: y2, end: y});\r\n  y = yDim.start;\r\n  y2 = yDim.end;\r\n\r\n  return {\r\n    x,\r\n    y,\r\n    x2,\r\n    y2,\r\n    width: x2 - x,\r\n    height: y2 - y,\r\n    centerX: x + (x2 - x) / 2,\r\n    centerY: y + (y2 - y) / 2\r\n  };\r\n}\r\n\r\n/**\r\n * @param {Chart} chart\r\n * @param {PointAnnotationOptions|PolygonAnnotationOptions} options\r\n * @returns {AnnotationBoxModel}\r\n */\r\nfunction resolvePointProperties(chart, options) {\r\n  if (!isBoundToPoint(options)) {\r\n    const box = resolveBoxProperties(chart, options);\r\n    let radius = options.radius;\r\n    if (!radius || isNaN(radius)) {\r\n      radius = Math.min(box.width, box.height) / 2;\r\n      options.radius = radius;\r\n    }\r\n    const size = radius * 2;\r\n    const adjustCenterX = box.centerX + options.xAdjust;\r\n    const adjustCenterY = box.centerY + options.yAdjust;\r\n    return {\r\n      x: adjustCenterX - radius,\r\n      y: adjustCenterY - radius,\r\n      x2: adjustCenterX + radius,\r\n      y2: adjustCenterY + radius,\r\n      centerX: adjustCenterX,\r\n      centerY: adjustCenterY,\r\n      width: size,\r\n      height: size,\r\n      radius\r\n    };\r\n  }\r\n  return getChartCircle(chart, options);\r\n}\r\n/**\r\n * @param {Chart} chart\r\n * @param {LineAnnotationOptions} options\r\n * @returns {AnnotationBoxModel}\r\n */\r\nfunction resolveLineProperties(chart, options) {\r\n  const {scales, chartArea} = chart;\r\n  const scale = scales[options.scaleID];\r\n  const area = {x: chartArea.left, y: chartArea.top, x2: chartArea.right, y2: chartArea.bottom};\r\n\r\n  if (scale) {\r\n    resolveFullLineProperties(scale, area, options);\r\n  } else {\r\n    resolveLimitedLineProperties(scales, area, options);\r\n  }\r\n  return area;\r\n}\r\n\r\n/**\r\n * @param {Chart} chart\r\n * @param {CoreAnnotationOptions} options\r\n * @param {boolean} [centerBased=false]\r\n * @returns {AnnotationBoxModel}\r\n */\r\nfunction resolveBoxAndLabelProperties(chart, options) {\r\n  const properties = resolveBoxProperties(chart, options);\r\n  properties.initProperties = initAnimationProperties(chart, properties, options);\r\n  properties.elements = [{\r\n    type: 'label',\r\n    optionScope: 'label',\r\n    properties: resolveLabelElementProperties$1(chart, properties, options),\r\n    initProperties: properties.initProperties\r\n  }];\r\n  return properties;\r\n}\r\n\r\nfunction getChartCircle(chart, options) {\r\n  const point = getChartPoint(chart, options);\r\n  const size = options.radius * 2;\r\n  return {\r\n    x: point.x - options.radius + options.xAdjust,\r\n    y: point.y - options.radius + options.yAdjust,\r\n    x2: point.x + options.radius + options.xAdjust,\r\n    y2: point.y + options.radius + options.yAdjust,\r\n    centerX: point.x + options.xAdjust,\r\n    centerY: point.y + options.yAdjust,\r\n    radius: options.radius,\r\n    width: size,\r\n    height: size\r\n  };\r\n}\r\n\r\nfunction getChartDimensionByScale(scale, options) {\r\n  const result = getDimensionByScale(scale, options) || options;\r\n  return {\r\n    start: Math.min(result.start, result.end),\r\n    end: Math.max(result.start, result.end)\r\n  };\r\n}\r\n\r\nfunction resolveFullLineProperties(scale, area, options) {\r\n  const min = scaleValue(scale, options.value, NaN);\r\n  const max = scaleValue(scale, options.endValue, min);\r\n  if (scale.isHorizontal()) {\r\n    area.x = min;\r\n    area.x2 = max;\r\n  } else {\r\n    area.y = min;\r\n    area.y2 = max;\r\n  }\r\n}\r\n\r\nfunction resolveLimitedLineProperties(scales, area, options) {\r\n  for (const scaleId of Object.keys(limitedLineScale)) {\r\n    const scale = scales[retrieveScaleID(scales, options, scaleId)];\r\n    if (scale) {\r\n      const {min, max, start, end, startProp, endProp} = limitedLineScale[scaleId];\r\n      const dim = getDimensionByScale(scale, {min: options[min], max: options[max], start: scale[start], end: scale[end]});\r\n      area[startProp] = dim.start;\r\n      area[endProp] = dim.end;\r\n    }\r\n  }\r\n}\r\n\r\nfunction calculateX({properties, options}, labelSize, position, padding) {\r\n  const {x: start, x2: end, width: size} = properties;\r\n  return calculatePosition$1({start, end, size, borderWidth: options.borderWidth}, {\r\n    position: position.x,\r\n    padding: {start: padding.left, end: padding.right},\r\n    adjust: options.label.xAdjust,\r\n    size: labelSize.width\r\n  });\r\n}\r\n\r\nfunction calculateY({properties, options}, labelSize, position, padding) {\r\n  const {y: start, y2: end, height: size} = properties;\r\n  return calculatePosition$1({start, end, size, borderWidth: options.borderWidth}, {\r\n    position: position.y,\r\n    padding: {start: padding.top, end: padding.bottom},\r\n    adjust: options.label.yAdjust,\r\n    size: labelSize.height\r\n  });\r\n}\r\n\r\nfunction calculatePosition$1(boxOpts, labelOpts) {\r\n  const {start, end, borderWidth} = boxOpts;\r\n  const {position, padding: {start: padStart, end: padEnd}, adjust} = labelOpts;\r\n  const availableSize = end - borderWidth - start - padStart - padEnd - labelOpts.size;\r\n  return start + borderWidth / 2 + adjust + getRelativePosition(availableSize, position);\r\n}\r\n\r\nfunction resolveLabelElementProperties$1(chart, properties, options) {\r\n  const label = options.label;\r\n  label.backgroundColor = 'transparent';\r\n  label.callout.display = false;\r\n  const position = toPosition(label.position);\r\n  const padding = toPadding(label.padding);\r\n  const labelSize = measureLabelSize(chart.ctx, label);\r\n  const x = calculateX({properties, options}, labelSize, position, padding);\r\n  const y = calculateY({properties, options}, labelSize, position, padding);\r\n  const width = labelSize.width + padding.width;\r\n  const height = labelSize.height + padding.height;\r\n  return {\r\n    x,\r\n    y,\r\n    x2: x + width,\r\n    y2: y + height,\r\n    width,\r\n    height,\r\n    centerX: x + width / 2,\r\n    centerY: y + height / 2,\r\n    rotation: label.rotation\r\n  };\r\n\r\n}\r\n\r\n/**\r\n * @typedef {import('chart.js').Point} Point\r\n */\r\n\r\n/**\r\n * Rotate a `point` relative to `center` point by `angle`\r\n * @param {Point} point - the point to rotate\r\n * @param {Point} center - center point for rotation\r\n * @param {number} angle - angle for rotation, in radians\r\n * @returns {Point} rotated point\r\n */\r\nfunction rotated(point, center, angle) {\r\n  const cos = Math.cos(angle);\r\n  const sin = Math.sin(angle);\r\n  const cx = center.x;\r\n  const cy = center.y;\r\n\r\n  return {\r\n    x: cx + cos * (point.x - cx) - sin * (point.y - cy),\r\n    y: cy + sin * (point.x - cx) + cos * (point.y - cy)\r\n  };\r\n}\r\n\r\nconst moveHooks = ['enter', 'leave'];\r\n\r\n/**\r\n * @typedef { import(\"chart.js\").Chart } Chart\r\n * @typedef { import('../../types/options').AnnotationPluginOptions } AnnotationPluginOptions\r\n */\r\n\r\nconst eventHooks = moveHooks.concat('click');\r\n\r\n/**\r\n * @param {Chart} chart\r\n * @param {Object} state\r\n * @param {AnnotationPluginOptions} options\r\n */\r\nfunction updateListeners(chart, state, options) {\r\n  state.listened = loadHooks(options, eventHooks, state.listeners);\r\n  state.moveListened = false;\r\n  state._getElements = getElements; // for testing\r\n\r\n  moveHooks.forEach(hook => {\r\n    if (isFunction(options[hook])) {\r\n      state.moveListened = true;\r\n    }\r\n  });\r\n\r\n  if (!state.listened || !state.moveListened) {\r\n    state.annotations.forEach(scope => {\r\n      if (!state.listened && isFunction(scope.click)) {\r\n        state.listened = true;\r\n      }\r\n      if (!state.moveListened) {\r\n        moveHooks.forEach(hook => {\r\n          if (isFunction(scope[hook])) {\r\n            state.listened = true;\r\n            state.moveListened = true;\r\n          }\r\n        });\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Object} state\r\n * @param {ChartEvent} event\r\n * @param {AnnotationPluginOptions} options\r\n * @return {boolean|undefined}\r\n */\r\nfunction handleEvent(state, event, options) {\r\n  if (state.listened) {\r\n    switch (event.type) {\r\n    case 'mousemove':\r\n    case 'mouseout':\r\n      return handleMoveEvents(state, event, options);\r\n    case 'click':\r\n      return handleClickEvents(state, event, options);\r\n    }\r\n  }\r\n}\r\n\r\nfunction handleMoveEvents(state, event, options) {\r\n  if (!state.moveListened) {\r\n    return;\r\n  }\r\n\r\n  let elements;\r\n\r\n  if (event.type === 'mousemove') {\r\n    elements = getElements(state, event, options.interaction);\r\n  } else {\r\n    elements = [];\r\n  }\r\n\r\n  const previous = state.hovered;\r\n  state.hovered = elements;\r\n\r\n  const context = {state, event};\r\n  let changed = dispatchMoveEvents(context, 'leave', previous, elements);\r\n  return dispatchMoveEvents(context, 'enter', elements, previous) || changed;\r\n}\r\n\r\nfunction dispatchMoveEvents({state, event}, hook, elements, checkElements) {\r\n  let changed;\r\n  for (const element of elements) {\r\n    if (checkElements.indexOf(element) < 0) {\r\n      changed = dispatchEvent(element.options[hook] || state.listeners[hook], element, event) || changed;\r\n    }\r\n  }\r\n  return changed;\r\n}\r\n\r\nfunction handleClickEvents(state, event, options) {\r\n  const listeners = state.listeners;\r\n  const elements = getElements(state, event, options.interaction);\r\n  let changed;\r\n  for (const element of elements) {\r\n    changed = dispatchEvent(element.options.click || listeners.click, element, event) || changed;\r\n  }\r\n  return changed;\r\n}\r\n\r\nfunction dispatchEvent(handler, element, event) {\r\n  return callback(handler, [element.$context, event]) === true;\r\n}\r\n\r\n/**\r\n * @typedef { import(\"chart.js\").Chart } Chart\r\n * @typedef { import('../../types/options').AnnotationPluginOptions } AnnotationPluginOptions\r\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\r\n */\r\n\r\nconst elementHooks = ['afterDraw', 'beforeDraw'];\r\n\r\n/**\r\n * @param {Chart} chart\r\n * @param {Object} state\r\n * @param {AnnotationPluginOptions} options\r\n */\r\nfunction updateHooks(chart, state, options) {\r\n  const visibleElements = state.visibleElements;\r\n  state.hooked = loadHooks(options, elementHooks, state.hooks);\r\n\r\n  if (!state.hooked) {\r\n    visibleElements.forEach(scope => {\r\n      if (!state.hooked) {\r\n        elementHooks.forEach(hook => {\r\n          if (isFunction(scope.options[hook])) {\r\n            state.hooked = true;\r\n          }\r\n        });\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Object} state\r\n * @param {AnnotationElement} element\r\n * @param {string} hook\r\n */\r\nfunction invokeHook(state, element, hook) {\r\n  if (state.hooked) {\r\n    const callbackHook = element.options[hook] || state.hooks[hook];\r\n    return callback(callbackHook, [element.$context]);\r\n  }\r\n}\r\n\r\n/**\r\n * @typedef { import(\"chart.js\").Chart } Chart\r\n * @typedef { import(\"chart.js\").Scale } Scale\r\n * @typedef { import('../../types/options').CoreAnnotationOptions } CoreAnnotationOptions\r\n */\r\n\r\n/**\r\n * @param {Chart} chart\r\n * @param {Scale} scale\r\n * @param {CoreAnnotationOptions[]} annotations\r\n */\r\nfunction adjustScaleRange(chart, scale, annotations) {\r\n  const range = getScaleLimits(chart.scales, scale, annotations);\r\n  let changed = changeScaleLimit(scale, range, 'min', 'suggestedMin');\r\n  changed = changeScaleLimit(scale, range, 'max', 'suggestedMax') || changed;\r\n  if (changed && isFunction(scale.handleTickRangeOptions)) {\r\n    scale.handleTickRangeOptions();\r\n  }\r\n}\r\n\r\n/**\r\n * @param {CoreAnnotationOptions[]} annotations\r\n * @param {{ [key: string]: Scale }} scales\r\n */\r\nfunction verifyScaleOptions(annotations, scales) {\r\n  for (const annotation of annotations) {\r\n    verifyScaleIDs(annotation, scales);\r\n  }\r\n}\r\n\r\nfunction changeScaleLimit(scale, range, limit, suggestedLimit) {\r\n  if (isFinite(range[limit]) && !scaleLimitDefined(scale.options, limit, suggestedLimit)) {\r\n    const changed = scale[limit] !== range[limit];\r\n    scale[limit] = range[limit];\r\n    return changed;\r\n  }\r\n}\r\n\r\nfunction scaleLimitDefined(scaleOptions, limit, suggestedLimit) {\r\n  return defined(scaleOptions[limit]) || defined(scaleOptions[suggestedLimit]);\r\n}\r\n\r\nfunction verifyScaleIDs(annotation, scales) {\r\n  for (const key of ['scaleID', 'xScaleID', 'yScaleID']) {\r\n    const scaleID = retrieveScaleID(scales, annotation, key);\r\n    if (scaleID && !scales[scaleID] && verifyProperties(annotation, key)) {\r\n      console.warn(`No scale found with id '${scaleID}' for annotation '${annotation.id}'`);\r\n    }\r\n  }\r\n}\r\n\r\nfunction verifyProperties(annotation, key) {\r\n  if (key === 'scaleID') {\r\n    return true;\r\n  }\r\n  const axis = key.charAt(0);\r\n  for (const prop of ['Min', 'Max', 'Value']) {\r\n    if (defined(annotation[axis + prop])) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction getScaleLimits(scales, scale, annotations) {\r\n  const axis = scale.axis;\r\n  const scaleID = scale.id;\r\n  const scaleIDOption = axis + 'ScaleID';\r\n  const limits = {\r\n    min: valueOrDefault(scale.min, Number.NEGATIVE_INFINITY),\r\n    max: valueOrDefault(scale.max, Number.POSITIVE_INFINITY)\r\n  };\r\n  for (const annotation of annotations) {\r\n    if (annotation.scaleID === scaleID) {\r\n      updateLimits(annotation, scale, ['value', 'endValue'], limits);\r\n    } else if (retrieveScaleID(scales, annotation, scaleIDOption) === scaleID) {\r\n      updateLimits(annotation, scale, [axis + 'Min', axis + 'Max', axis + 'Value'], limits);\r\n    }\r\n  }\r\n  return limits;\r\n}\r\n\r\nfunction updateLimits(annotation, scale, props, limits) {\r\n  for (const prop of props) {\r\n    const raw = annotation[prop];\r\n    if (defined(raw)) {\r\n      const value = scale.parse(raw);\r\n      limits.min = Math.min(limits.min, value);\r\n      limits.max = Math.max(limits.max, value);\r\n    }\r\n  }\r\n}\r\n\r\nclass BoxAnnotation extends Element {\r\n\r\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\r\n    const {x, y} = rotated({x: mouseX, y: mouseY}, this.getCenterPoint(useFinalPosition), toRadians(-this.options.rotation));\r\n    return inBoxRange({x, y}, this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), axis, this.options.borderWidth);\r\n  }\r\n\r\n  getCenterPoint(useFinalPosition) {\r\n    return getElementCenterPoint(this, useFinalPosition);\r\n  }\r\n\r\n  draw(ctx) {\r\n    ctx.save();\r\n    translate(ctx, this.getCenterPoint(), this.options.rotation);\r\n    drawBox(ctx, this, this.options);\r\n    ctx.restore();\r\n  }\r\n\r\n  get label() {\r\n    return this.elements && this.elements[0];\r\n  }\r\n\r\n  resolveElementProperties(chart, options) {\r\n    return resolveBoxAndLabelProperties(chart, options);\r\n  }\r\n}\r\n\r\nBoxAnnotation.id = 'boxAnnotation';\r\n\r\nBoxAnnotation.defaults = {\r\n  adjustScaleRange: true,\r\n  backgroundShadowColor: 'transparent',\r\n  borderCapStyle: 'butt',\r\n  borderDash: [],\r\n  borderDashOffset: 0,\r\n  borderJoinStyle: 'miter',\r\n  borderRadius: 0,\r\n  borderShadowColor: 'transparent',\r\n  borderWidth: 1,\r\n  display: true,\r\n  init: undefined,\r\n  label: {\r\n    backgroundColor: 'transparent',\r\n    borderWidth: 0,\r\n    callout: {\r\n      display: false\r\n    },\r\n    color: 'black',\r\n    content: null,\r\n    display: false,\r\n    drawTime: undefined,\r\n    font: {\r\n      family: undefined,\r\n      lineHeight: undefined,\r\n      size: undefined,\r\n      style: undefined,\r\n      weight: 'bold'\r\n    },\r\n    height: undefined,\r\n    opacity: undefined,\r\n    padding: 6,\r\n    position: 'center',\r\n    rotation: undefined,\r\n    textAlign: 'start',\r\n    textStrokeColor: undefined,\r\n    textStrokeWidth: 0,\r\n    width: undefined,\r\n    xAdjust: 0,\r\n    yAdjust: 0,\r\n    z: undefined\r\n  },\r\n  rotation: 0,\r\n  shadowBlur: 0,\r\n  shadowOffsetX: 0,\r\n  shadowOffsetY: 0,\r\n  xMax: undefined,\r\n  xMin: undefined,\r\n  xScaleID: undefined,\r\n  yMax: undefined,\r\n  yMin: undefined,\r\n  yScaleID: undefined,\r\n  z: 0\r\n};\r\n\r\nBoxAnnotation.defaultRoutes = {\r\n  borderColor: 'color',\r\n  backgroundColor: 'color'\r\n};\r\n\r\nBoxAnnotation.descriptors = {\r\n  label: {\r\n    _fallback: true\r\n  }\r\n};\r\n\r\nconst positions = ['left', 'bottom', 'top', 'right'];\r\n\r\nclass LabelAnnotation extends Element {\r\n\r\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\r\n    const {x, y} = rotated({x: mouseX, y: mouseY}, this.getCenterPoint(useFinalPosition), toRadians(-this.rotation));\r\n    return inBoxRange({x, y}, this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), axis, this.options.borderWidth);\r\n  }\r\n\r\n  getCenterPoint(useFinalPosition) {\r\n    return getElementCenterPoint(this, useFinalPosition);\r\n  }\r\n\r\n  draw(ctx) {\r\n    const options = this.options;\r\n    const visible = !defined(this._visible) || this._visible;\r\n    if (!options.display || !options.content || !visible) {\r\n      return;\r\n    }\r\n    ctx.save();\r\n    translate(ctx, this.getCenterPoint(), this.rotation);\r\n    drawCallout(ctx, this);\r\n    drawBox(ctx, this, options);\r\n    drawLabel(ctx, getLabelSize(this), options);\r\n    ctx.restore();\r\n  }\r\n\r\n  resolveElementProperties(chart, options) {\r\n    let point;\r\n    if (!isBoundToPoint(options)) {\r\n      const {centerX, centerY} = resolveBoxProperties(chart, options);\r\n      point = {x: centerX, y: centerY};\r\n    } else {\r\n      point = getChartPoint(chart, options);\r\n    }\r\n    const padding = toPadding(options.padding);\r\n    const labelSize = measureLabelSize(chart.ctx, options);\r\n    const boxSize = measureRect(point, labelSize, options, padding);\r\n    return {\r\n      initProperties: initAnimationProperties(chart, boxSize, options),\r\n      pointX: point.x,\r\n      pointY: point.y,\r\n      ...boxSize,\r\n      rotation: options.rotation\r\n    };\r\n  }\r\n}\r\n\r\nLabelAnnotation.id = 'labelAnnotation';\r\n\r\nLabelAnnotation.defaults = {\r\n  adjustScaleRange: true,\r\n  backgroundColor: 'transparent',\r\n  backgroundShadowColor: 'transparent',\r\n  borderCapStyle: 'butt',\r\n  borderDash: [],\r\n  borderDashOffset: 0,\r\n  borderJoinStyle: 'miter',\r\n  borderRadius: 0,\r\n  borderShadowColor: 'transparent',\r\n  borderWidth: 0,\r\n  callout: {\r\n    borderCapStyle: 'butt',\r\n    borderColor: undefined,\r\n    borderDash: [],\r\n    borderDashOffset: 0,\r\n    borderJoinStyle: 'miter',\r\n    borderWidth: 1,\r\n    display: false,\r\n    margin: 5,\r\n    position: 'auto',\r\n    side: 5,\r\n    start: '50%',\r\n  },\r\n  color: 'black',\r\n  content: null,\r\n  display: true,\r\n  font: {\r\n    family: undefined,\r\n    lineHeight: undefined,\r\n    size: undefined,\r\n    style: undefined,\r\n    weight: undefined\r\n  },\r\n  height: undefined,\r\n  init: undefined,\r\n  opacity: undefined,\r\n  padding: 6,\r\n  position: 'center',\r\n  rotation: 0,\r\n  shadowBlur: 0,\r\n  shadowOffsetX: 0,\r\n  shadowOffsetY: 0,\r\n  textAlign: 'center',\r\n  textStrokeColor: undefined,\r\n  textStrokeWidth: 0,\r\n  width: undefined,\r\n  xAdjust: 0,\r\n  xMax: undefined,\r\n  xMin: undefined,\r\n  xScaleID: undefined,\r\n  xValue: undefined,\r\n  yAdjust: 0,\r\n  yMax: undefined,\r\n  yMin: undefined,\r\n  yScaleID: undefined,\r\n  yValue: undefined,\r\n  z: 0\r\n};\r\n\r\nLabelAnnotation.defaultRoutes = {\r\n  borderColor: 'color'\r\n};\r\n\r\nfunction measureRect(point, size, options, padding) {\r\n  const width = size.width + padding.width + options.borderWidth;\r\n  const height = size.height + padding.height + options.borderWidth;\r\n  const position = toPosition(options.position, 'center');\r\n  const x = calculatePosition(point.x, width, options.xAdjust, position.x);\r\n  const y = calculatePosition(point.y, height, options.yAdjust, position.y);\r\n\r\n  return {\r\n    x,\r\n    y,\r\n    x2: x + width,\r\n    y2: y + height,\r\n    width,\r\n    height,\r\n    centerX: x + width / 2,\r\n    centerY: y + height / 2\r\n  };\r\n}\r\n\r\nfunction calculatePosition(start, size, adjust = 0, position) {\r\n  return start - getRelativePosition(size, position) + adjust;\r\n}\r\n\r\nfunction drawCallout(ctx, element) {\r\n  const {pointX, pointY, options} = element;\r\n  const callout = options.callout;\r\n  const calloutPosition = callout && callout.display && resolveCalloutPosition(element, callout);\r\n  if (!calloutPosition || isPointInRange(element, callout, calloutPosition)) {\r\n    return;\r\n  }\r\n\r\n  ctx.save();\r\n  ctx.beginPath();\r\n  const stroke = setBorderStyle(ctx, callout);\r\n  if (!stroke) {\r\n    return ctx.restore();\r\n  }\r\n  const {separatorStart, separatorEnd} = getCalloutSeparatorCoord(element, calloutPosition);\r\n  const {sideStart, sideEnd} = getCalloutSideCoord(element, calloutPosition, separatorStart);\r\n  if (callout.margin > 0 || options.borderWidth === 0) {\r\n    ctx.moveTo(separatorStart.x, separatorStart.y);\r\n    ctx.lineTo(separatorEnd.x, separatorEnd.y);\r\n  }\r\n  ctx.moveTo(sideStart.x, sideStart.y);\r\n  ctx.lineTo(sideEnd.x, sideEnd.y);\r\n  const rotatedPoint = rotated({x: pointX, y: pointY}, element.getCenterPoint(), toRadians(-element.rotation));\r\n  ctx.lineTo(rotatedPoint.x, rotatedPoint.y);\r\n  ctx.stroke();\r\n  ctx.restore();\r\n}\r\n\r\nfunction getCalloutSeparatorCoord(element, position) {\r\n  const {x, y, x2, y2} = element;\r\n  const adjust = getCalloutSeparatorAdjust(element, position);\r\n  let separatorStart, separatorEnd;\r\n  if (position === 'left' || position === 'right') {\r\n    separatorStart = {x: x + adjust, y};\r\n    separatorEnd = {x: separatorStart.x, y: y2};\r\n  } else {\r\n    //  position 'top' or 'bottom'\r\n    separatorStart = {x, y: y + adjust};\r\n    separatorEnd = {x: x2, y: separatorStart.y};\r\n  }\r\n  return {separatorStart, separatorEnd};\r\n}\r\n\r\nfunction getCalloutSeparatorAdjust(element, position) {\r\n  const {width, height, options} = element;\r\n  const adjust = options.callout.margin + options.borderWidth / 2;\r\n  if (position === 'right') {\r\n    return width + adjust;\r\n  } else if (position === 'bottom') {\r\n    return height + adjust;\r\n  }\r\n  return -adjust;\r\n}\r\n\r\nfunction getCalloutSideCoord(element, position, separatorStart) {\r\n  const {y, width, height, options} = element;\r\n  const start = options.callout.start;\r\n  const side = getCalloutSideAdjust(position, options.callout);\r\n  let sideStart, sideEnd;\r\n  if (position === 'left' || position === 'right') {\r\n    sideStart = {x: separatorStart.x, y: y + getSize(height, start)};\r\n    sideEnd = {x: sideStart.x + side, y: sideStart.y};\r\n  } else {\r\n    //  position 'top' or 'bottom'\r\n    sideStart = {x: separatorStart.x + getSize(width, start), y: separatorStart.y};\r\n    sideEnd = {x: sideStart.x, y: sideStart.y + side};\r\n  }\r\n  return {sideStart, sideEnd};\r\n}\r\n\r\nfunction getCalloutSideAdjust(position, options) {\r\n  const side = options.side;\r\n  if (position === 'left' || position === 'top') {\r\n    return -side;\r\n  }\r\n  return side;\r\n}\r\n\r\nfunction resolveCalloutPosition(element, options) {\r\n  const position = options.position;\r\n  if (positions.includes(position)) {\r\n    return position;\r\n  }\r\n  return resolveCalloutAutoPosition(element, options);\r\n}\r\n\r\nfunction resolveCalloutAutoPosition(element, options) {\r\n  const {x, y, x2, y2, width, height, pointX, pointY, centerX, centerY, rotation} = element;\r\n  const center = {x: centerX, y: centerY};\r\n  const start = options.start;\r\n  const xAdjust = getSize(width, start);\r\n  const yAdjust = getSize(height, start);\r\n  const xPoints = [x, x + xAdjust, x + xAdjust, x2];\r\n  const yPoints = [y + yAdjust, y2, y, y2];\r\n  const result = [];\r\n  for (let index = 0; index < 4; index++) {\r\n    const rotatedPoint = rotated({x: xPoints[index], y: yPoints[index]}, center, toRadians(rotation));\r\n    result.push({\r\n      position: positions[index],\r\n      distance: distanceBetweenPoints(rotatedPoint, {x: pointX, y: pointY})\r\n    });\r\n  }\r\n  return result.sort((a, b) => a.distance - b.distance)[0].position;\r\n}\r\n\r\nfunction getLabelSize({x, y, width, height, options}) {\r\n  const hBorderWidth = options.borderWidth / 2;\r\n  const padding = toPadding(options.padding);\r\n  return {\r\n    x: x + padding.left + hBorderWidth,\r\n    y: y + padding.top + hBorderWidth,\r\n    width: width - padding.left - padding.right - options.borderWidth,\r\n    height: height - padding.top - padding.bottom - options.borderWidth\r\n  };\r\n}\r\n\r\nfunction isPointInRange(element, callout, position) {\r\n  const {pointX, pointY} = element;\r\n  const margin = callout.margin;\r\n  let x = pointX;\r\n  let y = pointY;\r\n  if (position === 'left') {\r\n    x += margin;\r\n  } else if (position === 'right') {\r\n    x -= margin;\r\n  } else if (position === 'top') {\r\n    y += margin;\r\n  } else if (position === 'bottom') {\r\n    y -= margin;\r\n  }\r\n  return element.inRange(x, y);\r\n}\r\n\r\nconst pointInLine = (p1, p2, t) => ({x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y)});\r\nconst interpolateX = (y, p1, p2) => pointInLine(p1, p2, Math.abs((y - p1.y) / (p2.y - p1.y))).x;\r\nconst interpolateY = (x, p1, p2) => pointInLine(p1, p2, Math.abs((x - p1.x) / (p2.x - p1.x))).y;\r\nconst sqr = v => v * v;\r\nconst rangeLimit = (mouseX, mouseY, {x, y, x2, y2}, axis) => axis === 'y' ? {start: Math.min(y, y2), end: Math.max(y, y2), value: mouseY} : {start: Math.min(x, x2), end: Math.max(x, x2), value: mouseX};\r\n// http://www.independent-software.com/determining-coordinates-on-a-html-canvas-bezier-curve.html\r\nconst coordInCurve = (start, cp, end, t) => (1 - t) * (1 - t) * start + 2 * (1 - t) * t * cp + t * t * end;\r\nconst pointInCurve = (start, cp, end, t) => ({x: coordInCurve(start.x, cp.x, end.x, t), y: coordInCurve(start.y, cp.y, end.y, t)});\r\nconst coordAngleInCurve = (start, cp, end, t) => 2 * (1 - t) * (cp - start) + 2 * t * (end - cp);\r\nconst angleInCurve = (start, cp, end, t) => -Math.atan2(coordAngleInCurve(start.x, cp.x, end.x, t), coordAngleInCurve(start.y, cp.y, end.y, t)) + 0.5 * PI;\r\n\r\nclass LineAnnotation extends Element {\r\n\r\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\r\n    const hBorderWidth = this.options.borderWidth / 2;\r\n    if (axis !== 'x' && axis !== 'y') {\r\n      const point = {mouseX, mouseY};\r\n      const {path, ctx} = this;\r\n      if (path) {\r\n        setBorderStyle(ctx, this.options);\r\n        const {chart} = this.$context;\r\n        const mx = mouseX * chart.currentDevicePixelRatio;\r\n        const my = mouseY * chart.currentDevicePixelRatio;\r\n        const result = ctx.isPointInStroke(path, mx, my) || isOnLabel(this, point, useFinalPosition);\r\n        ctx.restore();\r\n        return result;\r\n      }\r\n      const epsilon = sqr(hBorderWidth);\r\n      return intersects(this, point, epsilon, useFinalPosition) || isOnLabel(this, point, useFinalPosition);\r\n    }\r\n    return inAxisRange(this, {mouseX, mouseY}, axis, {hBorderWidth, useFinalPosition});\r\n  }\r\n\r\n  getCenterPoint(useFinalPosition) {\r\n    return getElementCenterPoint(this, useFinalPosition);\r\n  }\r\n\r\n  draw(ctx) {\r\n    const {x, y, x2, y2, cp, options} = this;\r\n\r\n    ctx.save();\r\n    if (!setBorderStyle(ctx, options)) {\r\n      // no border width, then line is not drawn\r\n      return ctx.restore();\r\n    }\r\n    setShadowStyle(ctx, options);\r\n\r\n    const length = Math.sqrt(Math.pow(x2 - x, 2) + Math.pow(y2 - y, 2));\r\n    if (options.curve && cp) {\r\n      drawCurve(ctx, this, cp, length);\r\n      return ctx.restore();\r\n    }\r\n    const {startOpts, endOpts, startAdjust, endAdjust} = getArrowHeads(this);\r\n    const angle = Math.atan2(y2 - y, x2 - x);\r\n    ctx.translate(x, y);\r\n    ctx.rotate(angle);\r\n    ctx.beginPath();\r\n    ctx.moveTo(0 + startAdjust, 0);\r\n    ctx.lineTo(length - endAdjust, 0);\r\n    ctx.shadowColor = options.borderShadowColor;\r\n    ctx.stroke();\r\n    drawArrowHead(ctx, 0, startAdjust, startOpts);\r\n    drawArrowHead(ctx, length, -endAdjust, endOpts);\r\n    ctx.restore();\r\n  }\r\n\r\n  get label() {\r\n    return this.elements && this.elements[0];\r\n  }\r\n\r\n  resolveElementProperties(chart, options) {\r\n    const area = resolveLineProperties(chart, options);\r\n    const {x, y, x2, y2} = area;\r\n    const inside = isLineInArea(area, chart.chartArea);\r\n    const properties = inside\r\n      ? limitLineToArea({x, y}, {x: x2, y: y2}, chart.chartArea)\r\n      : {x, y, x2, y2, width: Math.abs(x2 - x), height: Math.abs(y2 - y)};\r\n    properties.centerX = (x2 + x) / 2;\r\n    properties.centerY = (y2 + y) / 2;\r\n    properties.initProperties = initAnimationProperties(chart, properties, options);\r\n    if (options.curve) {\r\n      const p1 = {x: properties.x, y: properties.y};\r\n      const p2 = {x: properties.x2, y: properties.y2};\r\n      properties.cp = getControlPoint(properties, options, distanceBetweenPoints(p1, p2));\r\n    }\r\n    const labelProperties = resolveLabelElementProperties(chart, properties, options.label);\r\n    // additonal prop to manage zoom/pan\r\n    labelProperties._visible = inside;\r\n\r\n    properties.elements = [{\r\n      type: 'label',\r\n      optionScope: 'label',\r\n      properties: labelProperties,\r\n      initProperties: properties.initProperties\r\n    }];\r\n    return properties;\r\n  }\r\n}\r\n\r\nLineAnnotation.id = 'lineAnnotation';\r\n\r\nconst arrowHeadsDefaults = {\r\n  backgroundColor: undefined,\r\n  backgroundShadowColor: undefined,\r\n  borderColor: undefined,\r\n  borderDash: undefined,\r\n  borderDashOffset: undefined,\r\n  borderShadowColor: undefined,\r\n  borderWidth: undefined,\r\n  display: undefined,\r\n  fill: undefined,\r\n  length: undefined,\r\n  shadowBlur: undefined,\r\n  shadowOffsetX: undefined,\r\n  shadowOffsetY: undefined,\r\n  width: undefined\r\n};\r\n\r\nLineAnnotation.defaults = {\r\n  adjustScaleRange: true,\r\n  arrowHeads: {\r\n    display: false,\r\n    end: Object.assign({}, arrowHeadsDefaults),\r\n    fill: false,\r\n    length: 12,\r\n    start: Object.assign({}, arrowHeadsDefaults),\r\n    width: 6\r\n  },\r\n  borderDash: [],\r\n  borderDashOffset: 0,\r\n  borderShadowColor: 'transparent',\r\n  borderWidth: 2,\r\n  curve: false,\r\n  controlPoint: {\r\n    y: '-50%'\r\n  },\r\n  display: true,\r\n  endValue: undefined,\r\n  init: undefined,\r\n  label: {\r\n    backgroundColor: 'rgba(0,0,0,0.8)',\r\n    backgroundShadowColor: 'transparent',\r\n    borderCapStyle: 'butt',\r\n    borderColor: 'black',\r\n    borderDash: [],\r\n    borderDashOffset: 0,\r\n    borderJoinStyle: 'miter',\r\n    borderRadius: 6,\r\n    borderShadowColor: 'transparent',\r\n    borderWidth: 0,\r\n    callout: Object.assign({}, LabelAnnotation.defaults.callout),\r\n    color: '#fff',\r\n    content: null,\r\n    display: false,\r\n    drawTime: undefined,\r\n    font: {\r\n      family: undefined,\r\n      lineHeight: undefined,\r\n      size: undefined,\r\n      style: undefined,\r\n      weight: 'bold'\r\n    },\r\n    height: undefined,\r\n    opacity: undefined,\r\n    padding: 6,\r\n    position: 'center',\r\n    rotation: 0,\r\n    shadowBlur: 0,\r\n    shadowOffsetX: 0,\r\n    shadowOffsetY: 0,\r\n    textAlign: 'center',\r\n    textStrokeColor: undefined,\r\n    textStrokeWidth: 0,\r\n    width: undefined,\r\n    xAdjust: 0,\r\n    yAdjust: 0,\r\n    z: undefined\r\n  },\r\n  scaleID: undefined,\r\n  shadowBlur: 0,\r\n  shadowOffsetX: 0,\r\n  shadowOffsetY: 0,\r\n  value: undefined,\r\n  xMax: undefined,\r\n  xMin: undefined,\r\n  xScaleID: undefined,\r\n  yMax: undefined,\r\n  yMin: undefined,\r\n  yScaleID: undefined,\r\n  z: 0\r\n};\r\n\r\nLineAnnotation.descriptors = {\r\n  arrowHeads: {\r\n    start: {\r\n      _fallback: true\r\n    },\r\n    end: {\r\n      _fallback: true\r\n    },\r\n    _fallback: true\r\n  }\r\n};\r\n\r\nLineAnnotation.defaultRoutes = {\r\n  borderColor: 'color'\r\n};\r\n\r\nfunction inAxisRange(element, {mouseX, mouseY}, axis, {hBorderWidth, useFinalPosition}) {\r\n  const limit = rangeLimit(mouseX, mouseY, element.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), axis);\r\n  return (limit.value >= limit.start - hBorderWidth && limit.value <= limit.end + hBorderWidth) || isOnLabel(element, {mouseX, mouseY}, useFinalPosition, axis);\r\n}\r\n\r\nfunction isLineInArea({x, y, x2, y2}, {top, right, bottom, left}) {\r\n  return !(\r\n    (x < left && x2 < left) ||\r\n    (x > right && x2 > right) ||\r\n    (y < top && y2 < top) ||\r\n    (y > bottom && y2 > bottom)\r\n  );\r\n}\r\n\r\nfunction limitPointToArea({x, y}, p2, {top, right, bottom, left}) {\r\n  if (x < left) {\r\n    y = interpolateY(left, {x, y}, p2);\r\n    x = left;\r\n  }\r\n  if (x > right) {\r\n    y = interpolateY(right, {x, y}, p2);\r\n    x = right;\r\n  }\r\n  if (y < top) {\r\n    x = interpolateX(top, {x, y}, p2);\r\n    y = top;\r\n  }\r\n  if (y > bottom) {\r\n    x = interpolateX(bottom, {x, y}, p2);\r\n    y = bottom;\r\n  }\r\n  return {x, y};\r\n}\r\n\r\nfunction limitLineToArea(p1, p2, area) {\r\n  const {x, y} = limitPointToArea(p1, p2, area);\r\n  const {x: x2, y: y2} = limitPointToArea(p2, p1, area);\r\n  return {x, y, x2, y2, width: Math.abs(x2 - x), height: Math.abs(y2 - y)};\r\n}\r\n\r\nfunction intersects(element, {mouseX, mouseY}, epsilon = EPSILON, useFinalPosition) {\r\n  // Adapted from https://stackoverflow.com/a/6853926/25507\r\n  const {x: x1, y: y1, x2, y2} = element.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition);\r\n  const dx = x2 - x1;\r\n  const dy = y2 - y1;\r\n  const lenSq = sqr(dx) + sqr(dy);\r\n  const t = lenSq === 0 ? -1 : ((mouseX - x1) * dx + (mouseY - y1) * dy) / lenSq;\r\n  let xx, yy;\r\n  if (t < 0) {\r\n    xx = x1;\r\n    yy = y1;\r\n  } else if (t > 1) {\r\n    xx = x2;\r\n    yy = y2;\r\n  } else {\r\n    xx = x1 + t * dx;\r\n    yy = y1 + t * dy;\r\n  }\r\n  return (sqr(mouseX - xx) + sqr(mouseY - yy)) <= epsilon;\r\n}\r\n\r\nfunction isOnLabel(element, {mouseX, mouseY}, useFinalPosition, axis) {\r\n  const label = element.label;\r\n  return label.options.display && label.inRange(mouseX, mouseY, axis, useFinalPosition);\r\n}\r\n\r\nfunction resolveLabelElementProperties(chart, properties, options) {\r\n  const borderWidth = options.borderWidth;\r\n  const padding = toPadding(options.padding);\r\n  const textSize = measureLabelSize(chart.ctx, options);\r\n  const width = textSize.width + padding.width + borderWidth;\r\n  const height = textSize.height + padding.height + borderWidth;\r\n  return calculateLabelPosition(properties, options, {width, height, padding}, chart.chartArea);\r\n}\r\n\r\nfunction calculateAutoRotation(properties) {\r\n  const {x, y, x2, y2} = properties;\r\n  const rotation = Math.atan2(y2 - y, x2 - x);\r\n  // Flip the rotation if it goes > PI/2 or < -PI/2, so label stays upright\r\n  return rotation > PI / 2 ? rotation - PI : rotation < PI / -2 ? rotation + PI : rotation;\r\n}\r\n\r\nfunction calculateLabelPosition(properties, label, sizes, chartArea) {\r\n  const {width, height, padding} = sizes;\r\n  const {xAdjust, yAdjust} = label;\r\n  const p1 = {x: properties.x, y: properties.y};\r\n  const p2 = {x: properties.x2, y: properties.y2};\r\n  const rotation = label.rotation === 'auto' ? calculateAutoRotation(properties) : toRadians(label.rotation);\r\n  const size = rotatedSize(width, height, rotation);\r\n  const t = calculateT(properties, label, {labelSize: size, padding}, chartArea);\r\n  const pt = properties.cp ? pointInCurve(p1, properties.cp, p2, t) : pointInLine(p1, p2, t);\r\n  const xCoordinateSizes = {size: size.w, min: chartArea.left, max: chartArea.right, padding: padding.left};\r\n  const yCoordinateSizes = {size: size.h, min: chartArea.top, max: chartArea.bottom, padding: padding.top};\r\n  const centerX = adjustLabelCoordinate(pt.x, xCoordinateSizes) + xAdjust;\r\n  const centerY = adjustLabelCoordinate(pt.y, yCoordinateSizes) + yAdjust;\r\n  return {\r\n    x: centerX - (width / 2),\r\n    y: centerY - (height / 2),\r\n    x2: centerX + (width / 2),\r\n    y2: centerY + (height / 2),\r\n    centerX,\r\n    centerY,\r\n    pointX: pt.x,\r\n    pointY: pt.y,\r\n    width,\r\n    height,\r\n    rotation: toDegrees(rotation)\r\n  };\r\n}\r\n\r\nfunction rotatedSize(width, height, rotation) {\r\n  const cos = Math.cos(rotation);\r\n  const sin = Math.sin(rotation);\r\n  return {\r\n    w: Math.abs(width * cos) + Math.abs(height * sin),\r\n    h: Math.abs(width * sin) + Math.abs(height * cos)\r\n  };\r\n}\r\n\r\nfunction calculateT(properties, label, sizes, chartArea) {\r\n  let t;\r\n  const space = spaceAround(properties, chartArea);\r\n  if (label.position === 'start') {\r\n    t = calculateTAdjust({w: properties.x2 - properties.x, h: properties.y2 - properties.y}, sizes, label, space);\r\n  } else if (label.position === 'end') {\r\n    t = 1 - calculateTAdjust({w: properties.x - properties.x2, h: properties.y - properties.y2}, sizes, label, space);\r\n  } else {\r\n    t = getRelativePosition(1, label.position);\r\n  }\r\n  return t;\r\n}\r\n\r\nfunction calculateTAdjust(lineSize, sizes, label, space) {\r\n  const {labelSize, padding} = sizes;\r\n  const lineW = lineSize.w * space.dx;\r\n  const lineH = lineSize.h * space.dy;\r\n  const x = (lineW > 0) && ((labelSize.w / 2 + padding.left - space.x) / lineW);\r\n  const y = (lineH > 0) && ((labelSize.h / 2 + padding.top - space.y) / lineH);\r\n  return clamp(Math.max(x, y), 0, 0.25);\r\n}\r\n\r\nfunction spaceAround(properties, chartArea) {\r\n  const {x, x2, y, y2} = properties;\r\n  const t = Math.min(y, y2) - chartArea.top;\r\n  const l = Math.min(x, x2) - chartArea.left;\r\n  const b = chartArea.bottom - Math.max(y, y2);\r\n  const r = chartArea.right - Math.max(x, x2);\r\n  return {\r\n    x: Math.min(l, r),\r\n    y: Math.min(t, b),\r\n    dx: l <= r ? 1 : -1,\r\n    dy: t <= b ? 1 : -1\r\n  };\r\n}\r\n\r\nfunction adjustLabelCoordinate(coordinate, labelSizes) {\r\n  const {size, min, max, padding} = labelSizes;\r\n  const halfSize = size / 2;\r\n  if (size > max - min) {\r\n    // if it does not fit, display as much as possible\r\n    return (max + min) / 2;\r\n  }\r\n  if (min >= (coordinate - padding - halfSize)) {\r\n    coordinate = min + padding + halfSize;\r\n  }\r\n  if (max <= (coordinate + padding + halfSize)) {\r\n    coordinate = max - padding - halfSize;\r\n  }\r\n  return coordinate;\r\n}\r\n\r\nfunction getArrowHeads(line) {\r\n  const options = line.options;\r\n  const arrowStartOpts = options.arrowHeads && options.arrowHeads.start;\r\n  const arrowEndOpts = options.arrowHeads && options.arrowHeads.end;\r\n  return {\r\n    startOpts: arrowStartOpts,\r\n    endOpts: arrowEndOpts,\r\n    startAdjust: getLineAdjust(line, arrowStartOpts),\r\n    endAdjust: getLineAdjust(line, arrowEndOpts)\r\n  };\r\n}\r\n\r\nfunction getLineAdjust(line, arrowOpts) {\r\n  if (!arrowOpts || !arrowOpts.display) {\r\n    return 0;\r\n  }\r\n  const {length, width} = arrowOpts;\r\n  const adjust = line.options.borderWidth / 2;\r\n  const p1 = {x: length, y: width + adjust};\r\n  const p2 = {x: 0, y: adjust};\r\n  return Math.abs(interpolateX(0, p1, p2));\r\n}\r\n\r\nfunction drawArrowHead(ctx, offset, adjust, arrowOpts) {\r\n  if (!arrowOpts || !arrowOpts.display) {\r\n    return;\r\n  }\r\n  const {length, width, fill, backgroundColor, borderColor} = arrowOpts;\r\n  const arrowOffsetX = Math.abs(offset - length) + adjust;\r\n  ctx.beginPath();\r\n  setShadowStyle(ctx, arrowOpts);\r\n  setBorderStyle(ctx, arrowOpts);\r\n  ctx.moveTo(arrowOffsetX, -width);\r\n  ctx.lineTo(offset + adjust, 0);\r\n  ctx.lineTo(arrowOffsetX, width);\r\n  if (fill === true) {\r\n    ctx.fillStyle = backgroundColor || borderColor;\r\n    ctx.closePath();\r\n    ctx.fill();\r\n    ctx.shadowColor = 'transparent';\r\n  } else {\r\n    ctx.shadowColor = arrowOpts.borderShadowColor;\r\n  }\r\n  ctx.stroke();\r\n}\r\n\r\nfunction getControlPoint(properties, options, distance) {\r\n  const {x, y, x2, y2, centerX, centerY} = properties;\r\n  const angle = Math.atan2(y2 - y, x2 - x);\r\n  const cp = toPosition(options.controlPoint, 0);\r\n  const point = {\r\n    x: centerX + getSize(distance, cp.x, false),\r\n    y: centerY + getSize(distance, cp.y, false)\r\n  };\r\n  return rotated(point, {x: centerX, y: centerY}, angle);\r\n}\r\n\r\nfunction drawArrowHeadOnCurve(ctx, {x, y}, {angle, adjust}, arrowOpts) {\r\n  if (!arrowOpts || !arrowOpts.display) {\r\n    return;\r\n  }\r\n  ctx.save();\r\n  ctx.translate(x, y);\r\n  ctx.rotate(angle);\r\n  drawArrowHead(ctx, 0, -adjust, arrowOpts);\r\n  ctx.restore();\r\n}\r\n\r\nfunction drawCurve(ctx, element, cp, length) {\r\n  const {x, y, x2, y2, options} = element;\r\n  const {startOpts, endOpts, startAdjust, endAdjust} = getArrowHeads(element);\r\n  const p1 = {x, y};\r\n  const p2 = {x: x2, y: y2};\r\n  const startAngle = angleInCurve(p1, cp, p2, 0);\r\n  const endAngle = angleInCurve(p1, cp, p2, 1) - PI;\r\n  const ps = pointInCurve(p1, cp, p2, startAdjust / length);\r\n  const pe = pointInCurve(p1, cp, p2, 1 - endAdjust / length);\r\n\r\n  const path = new Path2D();\r\n  ctx.beginPath();\r\n  path.moveTo(ps.x, ps.y);\r\n  path.quadraticCurveTo(cp.x, cp.y, pe.x, pe.y);\r\n  ctx.shadowColor = options.borderShadowColor;\r\n  ctx.stroke(path);\r\n  element.path = path;\r\n  element.ctx = ctx;\r\n  drawArrowHeadOnCurve(ctx, ps, {angle: startAngle, adjust: startAdjust}, startOpts);\r\n  drawArrowHeadOnCurve(ctx, pe, {angle: endAngle, adjust: endAdjust}, endOpts);\r\n}\r\n\r\nclass EllipseAnnotation extends Element {\r\n\r\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\r\n    const rotation = this.options.rotation;\r\n    const borderWidth = this.options.borderWidth;\r\n    if (axis !== 'x' && axis !== 'y') {\r\n      return pointInEllipse({x: mouseX, y: mouseY}, this.getProps(['width', 'height', 'centerX', 'centerY'], useFinalPosition), rotation, borderWidth);\r\n    }\r\n    const {x, y, x2, y2} = this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition);\r\n    const hBorderWidth = borderWidth / 2;\r\n    const limit = axis === 'y' ? {start: y, end: y2} : {start: x, end: x2};\r\n    const rotatedPoint = rotated({x: mouseX, y: mouseY}, this.getCenterPoint(useFinalPosition), toRadians(-rotation));\r\n    return rotatedPoint[axis] >= limit.start - hBorderWidth - EPSILON && rotatedPoint[axis] <= limit.end + hBorderWidth + EPSILON;\r\n  }\r\n\r\n  getCenterPoint(useFinalPosition) {\r\n    return getElementCenterPoint(this, useFinalPosition);\r\n  }\r\n\r\n  draw(ctx) {\r\n    const {width, height, centerX, centerY, options} = this;\r\n    ctx.save();\r\n    translate(ctx, this.getCenterPoint(), options.rotation);\r\n    setShadowStyle(ctx, this.options);\r\n    ctx.beginPath();\r\n    ctx.fillStyle = options.backgroundColor;\r\n    const stroke = setBorderStyle(ctx, options);\r\n    ctx.ellipse(centerX, centerY, height / 2, width / 2, PI / 2, 0, 2 * PI);\r\n    ctx.fill();\r\n    if (stroke) {\r\n      ctx.shadowColor = options.borderShadowColor;\r\n      ctx.stroke();\r\n    }\r\n    ctx.restore();\r\n  }\r\n\r\n  get label() {\r\n    return this.elements && this.elements[0];\r\n  }\r\n\r\n  resolveElementProperties(chart, options) {\r\n    return resolveBoxAndLabelProperties(chart, options);\r\n  }\r\n\r\n}\r\n\r\nEllipseAnnotation.id = 'ellipseAnnotation';\r\n\r\nEllipseAnnotation.defaults = {\r\n  adjustScaleRange: true,\r\n  backgroundShadowColor: 'transparent',\r\n  borderDash: [],\r\n  borderDashOffset: 0,\r\n  borderShadowColor: 'transparent',\r\n  borderWidth: 1,\r\n  display: true,\r\n  init: undefined,\r\n  label: Object.assign({}, BoxAnnotation.defaults.label),\r\n  rotation: 0,\r\n  shadowBlur: 0,\r\n  shadowOffsetX: 0,\r\n  shadowOffsetY: 0,\r\n  xMax: undefined,\r\n  xMin: undefined,\r\n  xScaleID: undefined,\r\n  yMax: undefined,\r\n  yMin: undefined,\r\n  yScaleID: undefined,\r\n  z: 0\r\n};\r\n\r\nEllipseAnnotation.defaultRoutes = {\r\n  borderColor: 'color',\r\n  backgroundColor: 'color'\r\n};\r\n\r\nEllipseAnnotation.descriptors = {\r\n  label: {\r\n    _fallback: true\r\n  }\r\n};\r\n\r\nfunction pointInEllipse(p, ellipse, rotation, borderWidth) {\r\n  const {width, height, centerX, centerY} = ellipse;\r\n  const xRadius = width / 2;\r\n  const yRadius = height / 2;\r\n\r\n  if (xRadius <= 0 || yRadius <= 0) {\r\n    return false;\r\n  }\r\n  // https://stackoverflow.com/questions/7946187/point-and-ellipse-rotated-position-test-algorithm\r\n  const angle = toRadians(rotation || 0);\r\n  const hBorderWidth = borderWidth / 2 || 0;\r\n  const cosAngle = Math.cos(angle);\r\n  const sinAngle = Math.sin(angle);\r\n  const a = Math.pow(cosAngle * (p.x - centerX) + sinAngle * (p.y - centerY), 2);\r\n  const b = Math.pow(sinAngle * (p.x - centerX) - cosAngle * (p.y - centerY), 2);\r\n  return (a / Math.pow(xRadius + hBorderWidth, 2)) + (b / Math.pow(yRadius + hBorderWidth, 2)) <= 1.0001;\r\n}\r\n\r\nclass PointAnnotation extends Element {\r\n\r\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\r\n    const {x, y, x2, y2, width} = this.getProps(['x', 'y', 'x2', 'y2', 'width'], useFinalPosition);\r\n    const borderWidth = this.options.borderWidth;\r\n    if (axis !== 'x' && axis !== 'y') {\r\n      return inPointRange({x: mouseX, y: mouseY}, this.getCenterPoint(useFinalPosition), width / 2, borderWidth);\r\n    }\r\n    const hBorderWidth = borderWidth / 2;\r\n    const limit = axis === 'y' ? {start: y, end: y2, value: mouseY} : {start: x, end: x2, value: mouseX};\r\n    return limit.value >= limit.start - hBorderWidth && limit.value <= limit.end + hBorderWidth;\r\n  }\r\n\r\n  getCenterPoint(useFinalPosition) {\r\n    return getElementCenterPoint(this, useFinalPosition);\r\n  }\r\n\r\n  draw(ctx) {\r\n    const options = this.options;\r\n    const borderWidth = options.borderWidth;\r\n    if (options.radius < 0.1) {\r\n      return;\r\n    }\r\n    ctx.save();\r\n    ctx.fillStyle = options.backgroundColor;\r\n    setShadowStyle(ctx, options);\r\n    const stroke = setBorderStyle(ctx, options);\r\n    drawPoint(ctx, this, this.centerX, this.centerY);\r\n    if (stroke && !isImageOrCanvas(options.pointStyle)) {\r\n      ctx.shadowColor = options.borderShadowColor;\r\n      ctx.stroke();\r\n    }\r\n    ctx.restore();\r\n    options.borderWidth = borderWidth;\r\n  }\r\n\r\n  resolveElementProperties(chart, options) {\r\n    const properties = resolvePointProperties(chart, options);\r\n    properties.initProperties = initAnimationProperties(chart, properties, options);\r\n    return properties;\r\n  }\r\n}\r\n\r\nPointAnnotation.id = 'pointAnnotation';\r\n\r\nPointAnnotation.defaults = {\r\n  adjustScaleRange: true,\r\n  backgroundShadowColor: 'transparent',\r\n  borderDash: [],\r\n  borderDashOffset: 0,\r\n  borderShadowColor: 'transparent',\r\n  borderWidth: 1,\r\n  display: true,\r\n  init: undefined,\r\n  pointStyle: 'circle',\r\n  radius: 10,\r\n  rotation: 0,\r\n  shadowBlur: 0,\r\n  shadowOffsetX: 0,\r\n  shadowOffsetY: 0,\r\n  xAdjust: 0,\r\n  xMax: undefined,\r\n  xMin: undefined,\r\n  xScaleID: undefined,\r\n  xValue: undefined,\r\n  yAdjust: 0,\r\n  yMax: undefined,\r\n  yMin: undefined,\r\n  yScaleID: undefined,\r\n  yValue: undefined,\r\n  z: 0\r\n};\r\n\r\nPointAnnotation.defaultRoutes = {\r\n  borderColor: 'color',\r\n  backgroundColor: 'color'\r\n};\r\n\r\nclass PolygonAnnotation extends Element {\r\n\r\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\r\n    if (axis !== 'x' && axis !== 'y') {\r\n      return this.options.radius >= 0.1 && this.elements.length > 1 && pointIsInPolygon(this.elements, mouseX, mouseY, useFinalPosition);\r\n    }\r\n    const rotatedPoint = rotated({x: mouseX, y: mouseY}, this.getCenterPoint(useFinalPosition), toRadians(-this.options.rotation));\r\n    const axisPoints = this.elements.map((point) => axis === 'y' ? point.bY : point.bX);\r\n    const start = Math.min(...axisPoints);\r\n    const end = Math.max(...axisPoints);\r\n    return rotatedPoint[axis] >= start && rotatedPoint[axis] <= end;\r\n  }\r\n\r\n  getCenterPoint(useFinalPosition) {\r\n    return getElementCenterPoint(this, useFinalPosition);\r\n  }\r\n\r\n  draw(ctx) {\r\n    const {elements, options} = this;\r\n    ctx.save();\r\n    ctx.beginPath();\r\n    ctx.fillStyle = options.backgroundColor;\r\n    setShadowStyle(ctx, options);\r\n    const stroke = setBorderStyle(ctx, options);\r\n    let first = true;\r\n    for (const el of elements) {\r\n      if (first) {\r\n        ctx.moveTo(el.x, el.y);\r\n        first = false;\r\n      } else {\r\n        ctx.lineTo(el.x, el.y);\r\n      }\r\n    }\r\n    ctx.closePath();\r\n    ctx.fill();\r\n    // If no border, don't draw it\r\n    if (stroke) {\r\n      ctx.shadowColor = options.borderShadowColor;\r\n      ctx.stroke();\r\n    }\r\n    ctx.restore();\r\n  }\r\n\r\n  resolveElementProperties(chart, options) {\r\n    const properties = resolvePointProperties(chart, options);\r\n    const {sides, rotation} = options;\r\n    const elements = [];\r\n    const angle = (2 * PI) / sides;\r\n    let rad = rotation * RAD_PER_DEG;\r\n    for (let i = 0; i < sides; i++, rad += angle) {\r\n      const elProps = buildPointElement(properties, options, rad);\r\n      elProps.initProperties = initAnimationProperties(chart, properties, options);\r\n      elements.push(elProps);\r\n    }\r\n    properties.elements = elements;\r\n    return properties;\r\n  }\r\n}\r\n\r\nPolygonAnnotation.id = 'polygonAnnotation';\r\n\r\nPolygonAnnotation.defaults = {\r\n  adjustScaleRange: true,\r\n  backgroundShadowColor: 'transparent',\r\n  borderCapStyle: 'butt',\r\n  borderDash: [],\r\n  borderDashOffset: 0,\r\n  borderJoinStyle: 'miter',\r\n  borderShadowColor: 'transparent',\r\n  borderWidth: 1,\r\n  display: true,\r\n  init: undefined,\r\n  point: {\r\n    radius: 0\r\n  },\r\n  radius: 10,\r\n  rotation: 0,\r\n  shadowBlur: 0,\r\n  shadowOffsetX: 0,\r\n  shadowOffsetY: 0,\r\n  sides: 3,\r\n  xAdjust: 0,\r\n  xMax: undefined,\r\n  xMin: undefined,\r\n  xScaleID: undefined,\r\n  xValue: undefined,\r\n  yAdjust: 0,\r\n  yMax: undefined,\r\n  yMin: undefined,\r\n  yScaleID: undefined,\r\n  yValue: undefined,\r\n  z: 0\r\n};\r\n\r\nPolygonAnnotation.defaultRoutes = {\r\n  borderColor: 'color',\r\n  backgroundColor: 'color'\r\n};\r\n\r\nfunction buildPointElement({centerX, centerY}, {radius, borderWidth}, rad) {\r\n  const halfBorder = borderWidth / 2;\r\n  const sin = Math.sin(rad);\r\n  const cos = Math.cos(rad);\r\n  const point = {x: centerX + sin * radius, y: centerY - cos * radius};\r\n  return {\r\n    type: 'point',\r\n    optionScope: 'point',\r\n    properties: {\r\n      x: point.x,\r\n      y: point.y,\r\n      centerX: point.x,\r\n      centerY: point.y,\r\n      bX: centerX + sin * (radius + halfBorder),\r\n      bY: centerY - cos * (radius + halfBorder)\r\n    }\r\n  };\r\n}\r\n\r\nfunction pointIsInPolygon(points, x, y, useFinalPosition) {\r\n  let isInside = false;\r\n  let A = points[points.length - 1].getProps(['bX', 'bY'], useFinalPosition);\r\n  for (const point of points) {\r\n    const B = point.getProps(['bX', 'bY'], useFinalPosition);\r\n    if ((B.bY > y) !== (A.bY > y) && x < (A.bX - B.bX) * (y - B.bY) / (A.bY - B.bY) + B.bX) {\r\n      isInside = !isInside;\r\n    }\r\n    A = B;\r\n  }\r\n  return isInside;\r\n}\r\n\r\nconst annotationTypes = {\r\n  box: BoxAnnotation,\r\n  ellipse: EllipseAnnotation,\r\n  label: LabelAnnotation,\r\n  line: LineAnnotation,\r\n  point: PointAnnotation,\r\n  polygon: PolygonAnnotation\r\n};\r\n\r\n/**\r\n * Register fallback for annotation elements\r\n * For example lineAnnotation options would be looked through:\r\n * - the annotation object (options.plugins.annotation.annotations[id])\r\n * - element options (options.elements.lineAnnotation)\r\n * - element defaults (defaults.elements.lineAnnotation)\r\n * - annotation plugin defaults (defaults.plugins.annotation, this is what we are registering here)\r\n */\r\nObject.keys(annotationTypes).forEach(key => {\r\n  defaults.describe(`elements.${annotationTypes[key].id}`, {\r\n    _fallback: 'plugins.annotation.common'\r\n  });\r\n});\r\n\r\nconst directUpdater = {\r\n  update: Object.assign\r\n};\r\n\r\nconst hooks$1 = eventHooks.concat(elementHooks);\r\nconst resolve = (value, optDefs) => isObject(optDefs) ? resolveObj(value, optDefs) : value;\r\n\r\n\r\n/**\r\n * @typedef { import(\"chart.js\").Chart } Chart\r\n * @typedef { import(\"chart.js\").UpdateMode } UpdateMode\r\n * @typedef { import('../../types/options').AnnotationPluginOptions } AnnotationPluginOptions\r\n */\r\n\r\n/**\r\n * @param {string} prop\r\n * @returns {boolean}\r\n */\r\nconst isIndexable = (prop) => prop === 'color' || prop === 'font';\r\n\r\n/**\r\n * Resolve the annotation type, checking if is supported.\r\n * @param {string} [type=line] - annotation type\r\n * @returns {string} resolved annotation type\r\n */\r\nfunction resolveType(type = 'line') {\r\n  if (annotationTypes[type]) {\r\n    return type;\r\n  }\r\n  console.warn(`Unknown annotation type: '${type}', defaulting to 'line'`);\r\n  return 'line';\r\n}\r\n\r\n/**\r\n * @param {Chart} chart\r\n * @param {Object} state\r\n * @param {AnnotationPluginOptions} options\r\n * @param {UpdateMode} mode\r\n */\r\nfunction updateElements(chart, state, options, mode) {\r\n  const animations = resolveAnimations(chart, options.animations, mode);\r\n\r\n  const annotations = state.annotations;\r\n  const elements = resyncElements(state.elements, annotations);\r\n\r\n  for (let i = 0; i < annotations.length; i++) {\r\n    const annotationOptions = annotations[i];\r\n    const element = getOrCreateElement(elements, i, annotationOptions.type);\r\n    const resolver = annotationOptions.setContext(getContext(chart, element, annotationOptions));\r\n    const properties = element.resolveElementProperties(chart, resolver);\r\n\r\n    properties.skip = toSkip(properties);\r\n\r\n    if ('elements' in properties) {\r\n      updateSubElements(element, properties.elements, resolver, animations);\r\n      // Remove the sub-element definitions from properties, so the actual elements\r\n      // are not overwritten by their definitions\r\n      delete properties.elements;\r\n    }\r\n\r\n    if (!defined(element.x)) {\r\n      // If the element is newly created, assing the properties directly - to\r\n      // make them readily awailable to any scriptable options. If we do not do this,\r\n      // the properties retruned by `resolveElementProperties` are available only\r\n      // after options resolution.\r\n      Object.assign(element, properties);\r\n    }\r\n\r\n    Object.assign(element, properties.initProperties);\r\n    properties.options = resolveAnnotationOptions(resolver);\r\n\r\n    animations.update(element, properties);\r\n  }\r\n}\r\n\r\nfunction toSkip(properties) {\r\n  return isNaN(properties.x) || isNaN(properties.y);\r\n}\r\n\r\nfunction resolveAnimations(chart, animOpts, mode) {\r\n  if (mode === 'reset' || mode === 'none' || mode === 'resize') {\r\n    return directUpdater;\r\n  }\r\n  return new Animations(chart, animOpts);\r\n}\r\n\r\nfunction updateSubElements(mainElement, elements, resolver, animations) {\r\n  const subElements = mainElement.elements || (mainElement.elements = []);\r\n  subElements.length = elements.length;\r\n  for (let i = 0; i < elements.length; i++) {\r\n    const definition = elements[i];\r\n    const properties = definition.properties;\r\n    const subElement = getOrCreateElement(subElements, i, definition.type, definition.initProperties);\r\n    const subResolver = resolver[definition.optionScope].override(definition);\r\n    properties.options = resolveAnnotationOptions(subResolver);\r\n    animations.update(subElement, properties);\r\n  }\r\n}\r\n\r\nfunction getOrCreateElement(elements, index, type, initProperties) {\r\n  const elementClass = annotationTypes[resolveType(type)];\r\n  let element = elements[index];\r\n  if (!element || !(element instanceof elementClass)) {\r\n    element = elements[index] = new elementClass();\r\n    Object.assign(element, initProperties);\r\n  }\r\n  return element;\r\n}\r\n\r\nfunction resolveAnnotationOptions(resolver) {\r\n  const elementClass = annotationTypes[resolveType(resolver.type)];\r\n  const result = {};\r\n  result.id = resolver.id;\r\n  result.type = resolver.type;\r\n  result.drawTime = resolver.drawTime;\r\n  Object.assign(result,\r\n    resolveObj(resolver, elementClass.defaults),\r\n    resolveObj(resolver, elementClass.defaultRoutes));\r\n  for (const hook of hooks$1) {\r\n    result[hook] = resolver[hook];\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction resolveObj(resolver, defs) {\r\n  const result = {};\r\n  for (const prop of Object.keys(defs)) {\r\n    const optDefs = defs[prop];\r\n    const value = resolver[prop];\r\n    if (isIndexable(prop) && isArray(value)) {\r\n      result[prop] = value.map((item) => resolve(item, optDefs));\r\n    } else {\r\n      result[prop] = resolve(value, optDefs);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction getContext(chart, element, annotation) {\r\n  return element.$context || (element.$context = Object.assign(Object.create(chart.getContext()), {\r\n    element,\r\n    id: annotation.id,\r\n    type: 'annotation'\r\n  }));\r\n}\r\n\r\nfunction resyncElements(elements, annotations) {\r\n  const count = annotations.length;\r\n  const start = elements.length;\r\n\r\n  if (start < count) {\r\n    const add = count - start;\r\n    elements.splice(start, 0, ...new Array(add));\r\n  } else if (start > count) {\r\n    elements.splice(count, start - count);\r\n  }\r\n  return elements;\r\n}\r\n\r\nvar version = \"3.0.1\";\r\n\r\nconst chartStates = new Map();\r\nconst hooks = eventHooks.concat(elementHooks);\r\n\r\nvar annotation = {\r\n  id: 'annotation',\r\n\r\n  version,\r\n\r\n  beforeRegister() {\r\n    requireVersion('chart.js', '4.0', Chart.version);\r\n  },\r\n\r\n  afterRegister() {\r\n    Chart.register(annotationTypes);\r\n  },\r\n\r\n  afterUnregister() {\r\n    Chart.unregister(annotationTypes);\r\n  },\r\n\r\n  beforeInit(chart) {\r\n    chartStates.set(chart, {\r\n      annotations: [],\r\n      elements: [],\r\n      visibleElements: [],\r\n      listeners: {},\r\n      listened: false,\r\n      moveListened: false,\r\n      hooks: {},\r\n      hooked: false,\r\n      hovered: []\r\n    });\r\n  },\r\n\r\n  beforeUpdate(chart, args, options) {\r\n    const state = chartStates.get(chart);\r\n    const annotations = state.annotations = [];\r\n\r\n    let annotationOptions = options.annotations;\r\n    if (isObject(annotationOptions)) {\r\n      Object.keys(annotationOptions).forEach(key => {\r\n        const value = annotationOptions[key];\r\n        if (isObject(value)) {\r\n          value.id = key;\r\n          annotations.push(value);\r\n        }\r\n      });\r\n    } else if (isArray(annotationOptions)) {\r\n      annotations.push(...annotationOptions);\r\n    }\r\n    verifyScaleOptions(annotations, chart.scales);\r\n  },\r\n\r\n  afterDataLimits(chart, args) {\r\n    const state = chartStates.get(chart);\r\n    adjustScaleRange(chart, args.scale, state.annotations.filter(a => a.display && a.adjustScaleRange));\r\n  },\r\n\r\n  afterUpdate(chart, args, options) {\r\n    const state = chartStates.get(chart);\r\n    updateListeners(chart, state, options);\r\n    updateElements(chart, state, options, args.mode);\r\n    state.visibleElements = state.elements.filter(el => !el.skip && el.options.display);\r\n    updateHooks(chart, state, options);\r\n  },\r\n\r\n  beforeDatasetsDraw(chart, _args, options) {\r\n    draw(chart, 'beforeDatasetsDraw', options.clip);\r\n  },\r\n\r\n  afterDatasetsDraw(chart, _args, options) {\r\n    draw(chart, 'afterDatasetsDraw', options.clip);\r\n  },\r\n\r\n  beforeDraw(chart, _args, options) {\r\n    draw(chart, 'beforeDraw', options.clip);\r\n  },\r\n\r\n  afterDraw(chart, _args, options) {\r\n    draw(chart, 'afterDraw', options.clip);\r\n  },\r\n\r\n  beforeEvent(chart, args, options) {\r\n    const state = chartStates.get(chart);\r\n    if (handleEvent(state, args.event, options)) {\r\n      args.changed = true;\r\n    }\r\n  },\r\n\r\n  afterDestroy(chart) {\r\n    chartStates.delete(chart);\r\n  },\r\n\r\n  _getState(chart) {\r\n    return chartStates.get(chart);\r\n  },\r\n\r\n  defaults: {\r\n    animations: {\r\n      numbers: {\r\n        properties: ['x', 'y', 'x2', 'y2', 'width', 'height', 'centerX', 'centerY', 'pointX', 'pointY', 'radius'],\r\n        type: 'number'\r\n      },\r\n    },\r\n    clip: true,\r\n    interaction: {\r\n      mode: undefined,\r\n      axis: undefined,\r\n      intersect: undefined\r\n    },\r\n    common: {\r\n      drawTime: 'afterDatasetsDraw',\r\n      init: false,\r\n      label: {\r\n      }\r\n    }\r\n  },\r\n\r\n  descriptors: {\r\n    _indexable: false,\r\n    _scriptable: (prop) => !hooks.includes(prop) && prop !== 'init',\r\n    annotations: {\r\n      _allKeys: false,\r\n      _fallback: (prop, opts) => `elements.${annotationTypes[resolveType(opts.type)].id}`\r\n    },\r\n    interaction: {\r\n      _fallback: true\r\n    },\r\n    common: {\r\n      label: {\r\n        _indexable: isIndexable,\r\n        _fallback: true\r\n      },\r\n      _indexable: isIndexable\r\n    }\r\n  },\r\n\r\n  additionalOptionScopes: ['']\r\n};\r\n\r\nfunction draw(chart, caller, clip) {\r\n  const {ctx, chartArea} = chart;\r\n  const state = chartStates.get(chart);\r\n\r\n  if (clip) {\r\n    clipArea(ctx, chartArea);\r\n  }\r\n\r\n  const drawableElements = getDrawableElements(state.visibleElements, caller).sort((a, b) => a.element.options.z - b.element.options.z);\r\n  for (const item of drawableElements) {\r\n    drawElement(ctx, chartArea, state, item);\r\n  }\r\n\r\n  if (clip) {\r\n    unclipArea(ctx);\r\n  }\r\n}\r\n\r\nfunction getDrawableElements(elements, caller) {\r\n  const drawableElements = [];\r\n  for (const el of elements) {\r\n    if (el.options.drawTime === caller) {\r\n      drawableElements.push({element: el, main: true});\r\n    }\r\n    if (el.elements && el.elements.length) {\r\n      for (const sub of el.elements) {\r\n        if (sub.options.display && sub.options.drawTime === caller) {\r\n          drawableElements.push({element: sub});\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return drawableElements;\r\n}\r\n\r\nfunction drawElement(ctx, chartArea, state, item) {\r\n  const el = item.element;\r\n  if (item.main) {\r\n    invokeHook(state, el, 'beforeDraw');\r\n    el.draw(ctx, chartArea);\r\n    invokeHook(state, el, 'afterDraw');\r\n  } else {\r\n    el.draw(ctx, chartArea);\r\n  }\r\n}\r\n\r\nexport { annotation as default };\r\n"],
  "mappings": "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",
  "names": ["hooks", "annotation"]
}
