import "./chunk-DA74IYYC.js";

// node_modules/vue-debounce/dist/vue-debounce.min.mjs
function e(e2, t2) {
  let n2 = null;
  const r2 = "number" == typeof t2 ? t2 : function(e3) {
    const [t3, n3 = "ms"] = String(e3).split(/(ms|s)/i);
    return Number(t3) * { ms: 1, s: 1e3 }[n3];
  }(t2), a2 = function() {
    for (var t3 = arguments.length, a3 = new Array(t3), c2 = 0; c2 < t3; c2++)
      a3[c2] = arguments[c2];
    const l2 = () => {
      n2 = null, e2.apply(this, a3);
    };
    clearTimeout(n2), n2 = setTimeout(l2, r2), n2 || e2.apply(this, a3);
  };
  return a2.cancel = () => {
    clearTimeout(n2), n2 = null;
  }, a2;
}
function t(e2) {
  return e2.map((e3) => e3.toLowerCase());
}
function n(e2, n2) {
  const r2 = e2 ? e2["debounce-events"] : [];
  return r2 && r2.length > 0 ? Array.isArray(r2) ? t(r2) : t(r2.split(",")) : t((a2 = n2, Array.isArray(a2) ? a2 : null == a2 ? [] : [a2]));
  var a2;
}
function r(e2) {
  return "" === e2;
}
function a(e2, t2) {
  return "Enter" === e2 && (!t2.lock || t2.unlock);
}
function c(e2, t2, n2) {
  return r(e2) && n2.fireonempty && ("Enter" === t2 || " " === t2);
}
function l() {
  let { lock: t2 = false, listenTo: l2 = "keyup", defaultTime: i2 = "300ms", fireOnEmpty: o = false, cancelOnEmpty: u = false, trim: s = false } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
  return { created(m, f, y) {
    let { value: p, arg: v = i2, modifiers: d } = f;
    const g = Object.assign({ lock: t2, trim: s, fireonempty: o, cancelonempty: u }, d), k = n(y.props, l2), E = e((e2) => {
      p(e2.target.value, e2);
    }, v);
    function h(e2) {
      const t3 = g.trim ? e2.target.value.trim() : e2.target.value;
      r(t3) && g.cancelonempty ? E.cancel() : a(e2.key, g) || c(t3, e2.key, g) ? (E.cancel(), p(e2.target.value, e2)) : E(e2);
    }
    k.forEach((e2) => {
      m.addEventListener(e2, h);
    });
  } };
}
var i = { install(t2) {
  let l2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  t2.directive("debounce", function() {
    let { lock: t3 = false, listenTo: l3 = "keyup", defaultTime: i2 = "300ms", fireOnEmpty: o = false, cancelOnEmpty: u = false, trim: s = false } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    return { bind(m, f, y) {
      let { value: p, arg: v = i2, modifiers: d } = f;
      const g = Object.assign({ lock: t3, trim: s, fireonempty: o, cancelonempty: u }, d), k = n(y.data.attrs, l3), E = e((e2) => {
        p(e2.target.value, e2);
      }, v);
      function h(e2) {
        const t4 = g.trim ? e2.target.value.trim() : e2.target.value;
        r(t4) && g.cancelonempty ? E.cancel() : a(e2.key, g) || c(t4, e2.key, g) ? (E.cancel(), p(e2.target.value, e2)) : E(e2);
      }
      k.forEach((e2) => {
        m.addEventListener(e2, h);
      });
    } };
  }(l2));
} };
export {
  e as debounce,
  i as default,
  l as vue3Debounce
};
//# sourceMappingURL=vue-debounce.js.map
