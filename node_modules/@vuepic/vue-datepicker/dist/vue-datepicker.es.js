import { openBlock, createElementBlock, createElementVNode, defineComponent, ref, inject, computed, unref, renderSlot, createCommentVNode, normalizeClass, withKeys, createBlock, withModifiers, reactive, onMounted, normalizeStyle, toDisplayString, Fragment, renderList, createTextVNode, createVNode, Transition, withCtx, nextTick, onBeforeUpdate, onUnmounted, createSlots, useSlots, withDirectives, mergeProps, normalizeProps, guardReactiveProps, vShow, isRef, resolveDynamicComponent, watch, getCurrentScope, onScopeDispose, toRef, provide, Teleport } from "vue";
import { getMonth, getYear, isEqual, parse, isValid, isDate, setHours, setMinutes, setSeconds, setMilliseconds, setMonth, setYear, getHours, getMinutes, getSeconds, format, isAfter, isBefore, set, parseISO, add, sub, startOfWeek, endOfWeek, addMonths, getDay, addDays, subMonths, addYears, subYears, getISOWeek, differenceInCalendarDays, eachDayOfInterval } from "date-fns";
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _sfc_main$h = {};
const _hoisted_1$g = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
};
const _hoisted_2$e = /* @__PURE__ */ createElementVNode("path", { d: "M29.333 8c0-2.208-1.792-4-4-4h-18.667c-2.208 0-4 1.792-4 4v18.667c0 2.208 1.792 4 4 4h18.667c2.208 0 4-1.792 4-4v-18.667zM26.667 8v18.667c0 0.736-0.597 1.333-1.333 1.333 0 0-18.667 0-18.667 0-0.736 0-1.333-0.597-1.333-1.333 0 0 0-18.667 0-18.667 0-0.736 0.597-1.333 1.333-1.333 0 0 18.667 0 18.667 0 0.736 0 1.333 0.597 1.333 1.333z" }, null, -1);
const _hoisted_3$e = /* @__PURE__ */ createElementVNode("path", { d: "M20 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z" }, null, -1);
const _hoisted_4$8 = /* @__PURE__ */ createElementVNode("path", { d: "M9.333 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z" }, null, -1);
const _hoisted_5$4 = /* @__PURE__ */ createElementVNode("path", { d: "M4 14.667h24c0.736 0 1.333-0.597 1.333-1.333s-0.597-1.333-1.333-1.333h-24c-0.736 0-1.333 0.597-1.333 1.333s0.597 1.333 1.333 1.333z" }, null, -1);
const _hoisted_6$2 = [
  _hoisted_2$e,
  _hoisted_3$e,
  _hoisted_4$8,
  _hoisted_5$4
];
function _sfc_render$6(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$g, _hoisted_6$2);
}
const CalendarIcon = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$6]]);
const _sfc_main$g = {};
const _hoisted_1$f = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
};
const _hoisted_2$d = /* @__PURE__ */ createElementVNode("path", { d: "M23.057 7.057l-16 16c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l16-16c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0z" }, null, -1);
const _hoisted_3$d = /* @__PURE__ */ createElementVNode("path", { d: "M7.057 8.943l16 16c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885l-16-16c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z" }, null, -1);
const _hoisted_4$7 = [
  _hoisted_2$d,
  _hoisted_3$d
];
function _sfc_render$5(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$f, _hoisted_4$7);
}
const CancelIcon = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$5]]);
const _sfc_main$f = {};
const _hoisted_1$e = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
};
const _hoisted_2$c = /* @__PURE__ */ createElementVNode("path", { d: "M20.943 23.057l-7.057-7.057c0 0 7.057-7.057 7.057-7.057 0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-8 8c-0.521 0.521-0.521 1.365 0 1.885l8 8c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z" }, null, -1);
const _hoisted_3$c = [
  _hoisted_2$c
];
function _sfc_render$4(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$e, _hoisted_3$c);
}
const ChevronLeftIcon = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$4]]);
const _sfc_main$e = {};
const _hoisted_1$d = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
};
const _hoisted_2$b = /* @__PURE__ */ createElementVNode("path", { d: "M12.943 24.943l8-8c0.521-0.521 0.521-1.365 0-1.885l-8-8c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885l7.057 7.057c0 0-7.057 7.057-7.057 7.057-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0z" }, null, -1);
const _hoisted_3$b = [
  _hoisted_2$b
];
function _sfc_render$3(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$d, _hoisted_3$b);
}
const ChevronRightIcon = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$3]]);
const _sfc_main$d = {};
const _hoisted_1$c = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
};
const _hoisted_2$a = /* @__PURE__ */ createElementVNode("path", { d: "M16 1.333c-8.095 0-14.667 6.572-14.667 14.667s6.572 14.667 14.667 14.667c8.095 0 14.667-6.572 14.667-14.667s-6.572-14.667-14.667-14.667zM16 4c6.623 0 12 5.377 12 12s-5.377 12-12 12c-6.623 0-12-5.377-12-12s5.377-12 12-12z" }, null, -1);
const _hoisted_3$a = /* @__PURE__ */ createElementVNode("path", { d: "M14.667 8v8c0 0.505 0.285 0.967 0.737 1.193l5.333 2.667c0.658 0.329 1.46 0.062 1.789-0.596s0.062-1.46-0.596-1.789l-4.596-2.298c0 0 0-7.176 0-7.176 0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z" }, null, -1);
const _hoisted_4$6 = [
  _hoisted_2$a,
  _hoisted_3$a
];
function _sfc_render$2(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$c, _hoisted_4$6);
}
const ClockIcon = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$2]]);
const _sfc_main$c = {};
const _hoisted_1$b = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
};
const _hoisted_2$9 = /* @__PURE__ */ createElementVNode("path", { d: "M24.943 19.057l-8-8c-0.521-0.521-1.365-0.521-1.885 0l-8 8c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l7.057-7.057c0 0 7.057 7.057 7.057 7.057 0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z" }, null, -1);
const _hoisted_3$9 = [
  _hoisted_2$9
];
function _sfc_render$1(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$b, _hoisted_3$9);
}
const ChevronUpIcon = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$1]]);
const _sfc_main$b = {};
const _hoisted_1$a = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
};
const _hoisted_2$8 = /* @__PURE__ */ createElementVNode("path", { d: "M7.057 12.943l8 8c0.521 0.521 1.365 0.521 1.885 0l8-8c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-7.057 7.057c0 0-7.057-7.057-7.057-7.057-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z" }, null, -1);
const _hoisted_3$8 = [
  _hoisted_2$8
];
function _sfc_render(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$a, _hoisted_3$8);
}
const ChevronDownIcon = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render]]);
const parseFreeInput = (value, pattern) => {
  const parsedDate = parse(value, pattern.slice(0, value.length), new Date());
  if (isValid(parsedDate) && isDate(parsedDate)) {
    return parsedDate;
  }
  return null;
};
const resetDateTime = (value) => {
  let dateParse = new Date(JSON.parse(JSON.stringify(value)));
  dateParse = setHours(dateParse, 0);
  dateParse = setMinutes(dateParse, 0);
  dateParse = setSeconds(dateParse, 0);
  dateParse = setMilliseconds(dateParse, 0);
  return dateParse;
};
const isValidDate = (value) => {
  if (Array.isArray(value)) {
    return isValid(value[0]) && (value[1] ? isValid(value[1]) : true);
  }
  return value ? isValid(value) : false;
};
const setDateTime = (date, hours, minutes, seconds) => {
  let dateCopy = date ? new Date(date) : new Date();
  if (hours || hours === 0) {
    dateCopy = setHours(dateCopy, +hours);
  }
  if (minutes || minutes === 0) {
    dateCopy = setMinutes(dateCopy, +minutes);
  }
  if (seconds || seconds === 0) {
    dateCopy = setSeconds(dateCopy, +seconds);
  }
  return setMilliseconds(dateCopy, 0);
};
const getNextMonthYear = (date) => {
  const newDate = addMonths(date, 1);
  return { month: getMonth(newDate), year: getYear(newDate) };
};
const setDateMonthOrYear = (date, month, year) => {
  let dateCopy = date ? new Date(date) : new Date();
  if (month || month === 0) {
    dateCopy = setMonth(dateCopy, month);
  }
  if (year) {
    dateCopy = setYear(dateCopy, year);
  }
  return dateCopy;
};
const getTimeFormat = (is24, seconds) => is24 ? `HH:mm${seconds ? ":ss" : ""}` : `hh:mm${seconds ? ":ss" : ""} aa`;
const getDefaultPattern = (pattern, is24, enableSeconds, monthPicker, timePicker, weekPicker, yearPicker, enableTimePicker) => {
  if (pattern) {
    return pattern;
  }
  if (monthPicker) {
    return "MM/yyyy";
  }
  if (timePicker) {
    return getTimeFormat(is24, enableSeconds);
  }
  if (weekPicker) {
    return "MM/dd/yyyy";
  }
  if (yearPicker) {
    return "yyyy";
  }
  return enableTimePicker ? `MM/dd/yyyy, ${getTimeFormat(is24, enableSeconds)}` : "MM/dd/yyyy";
};
const getTimeVal = (date) => {
  const dateValue = date || new Date();
  return {
    hours: getHours(dateValue),
    minutes: getMinutes(dateValue),
    seconds: getSeconds(dateValue)
  };
};
const getMonthVal = (date) => ({ month: getMonth(date), year: getYear(date) });
const getMonthValForExternal = (date) => {
  if (Array.isArray(date)) {
    return [getMonthVal(date[0]), date[1] ? getMonthVal(date[1]) : null];
  }
  return getMonthVal(date);
};
const getTImeForExternal = (date) => {
  if (Array.isArray(date)) {
    return [getTimeVal(date[0]), getTimeVal(date[1])];
  }
  return getTimeVal(date);
};
const formatFn = (value, pattern, locale) => {
  if (locale) {
    return format(value, pattern, { locale });
  }
  return format(value, pattern);
};
const formatDate = (value, pattern, locale, textInputSeparator, modelAuto) => {
  if (Array.isArray(value)) {
    return `${formatFn(value[0], pattern, locale)} ${modelAuto && !value[1] ? "" : textInputSeparator ? textInputSeparator : "-"} ${value[1] ? formatFn(value[1], pattern, locale) : ""}`;
  }
  return formatFn(value, pattern, locale);
};
const isDateAfter = (date, dateToCompare) => {
  if (!date || !dateToCompare) {
    return false;
  }
  return isAfter(resetDateTime(date), resetDateTime(dateToCompare));
};
const isDateBefore = (date, dateToCompare) => {
  if (!date || !dateToCompare) {
    return false;
  }
  return isBefore(resetDateTime(date), resetDateTime(dateToCompare));
};
const isDateEqual = (date, dateToCompare) => {
  if (!date || !dateToCompare) {
    return false;
  }
  return isEqual(resetDateTime(date), resetDateTime(dateToCompare));
};
const addTime = (initial, toAdd) => add(set(new Date(), initial), toAdd);
const subTime = (initial, toSub) => sub(set(new Date(), initial), toSub);
const setTimeValue = (date) => set(new Date(), { hours: getHours(date), minutes: getMinutes(date), seconds: getSeconds(date) });
const getMinMaxTime = (time) => {
  return set(new Date(), {
    hours: +time.hours || 0,
    minutes: +time.minutes || 0,
    seconds: +time.seconds || 0
  });
};
const validateTime = (date, dateToCompare, compare, full) => {
  if (!date)
    return true;
  if (full) {
    const valid = compare === "max" ? isBefore(date, dateToCompare) : isAfter(date, dateToCompare);
    const setOptions = { seconds: 0, milliseconds: 0 };
    return valid || isEqual(set(date, setOptions), set(dateToCompare, setOptions));
  }
  return compare === "max" ? date.getTime() <= dateToCompare.getTime() : date.getTime() >= dateToCompare.getTime();
};
const isValidTime = (date, maxTime, minTime, maxDate, minDate) => {
  let isValid2 = true;
  if (!date) {
    return true;
  }
  const selectedDateTime = !minDate && !maxDate ? Array.isArray(date) ? [date[0] ? setTimeValue(date[0]) : null, date[1] ? setTimeValue(date[1]) : null] : setTimeValue(date) : date;
  if (maxTime || maxDate) {
    const max = maxTime ? getMinMaxTime(maxTime) : new Date(maxDate);
    if (Array.isArray(selectedDateTime)) {
      isValid2 = validateTime(selectedDateTime[0], max, "max", !!maxDate) && validateTime(selectedDateTime[1], max, "max", !!maxDate);
    } else {
      isValid2 = validateTime(selectedDateTime, max, "max", !!maxDate);
    }
  }
  if (minTime || minDate) {
    const min = minTime ? getMinMaxTime(minTime) : new Date(minDate);
    if (Array.isArray(selectedDateTime)) {
      isValid2 = validateTime(selectedDateTime[0], min, "min", !!minDate) && validateTime(selectedDateTime[1], min, "min", !!minDate) && isValid2;
    } else {
      isValid2 = validateTime(selectedDateTime, min, "min", !!minDate) && isValid2;
    }
  }
  return isValid2;
};
const isMonthWithinRange = (date, minDate, maxDate) => {
  let valid = true;
  if (minDate && maxDate) {
    valid = isDateAfter(new Date(date), new Date(minDate)) && isDateBefore(new Date(date), new Date(maxDate));
  }
  if (minDate) {
    valid = isDateAfter(new Date(date), new Date(minDate));
  }
  if (maxDate) {
    valid = isDateBefore(new Date(date), new Date(maxDate));
  }
  return valid;
};
const sanitizeDate = (date) => {
  if (date instanceof Date) {
    return date;
  }
  return parseISO(date);
};
const dateToUtc = (date, preserve) => {
  if (preserve) {
    const tzOffset = new Date().getTimezoneOffset() * 6e4;
    return new Date(date.getTime() - tzOffset).toISOString();
  }
  const utcDate = Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds());
  return new Date(utcDate).toISOString();
};
const isDateBetween = (range, hoverDate, dateToCheck) => {
  if (range && range[0] && range[1]) {
    return isDateAfter(dateToCheck, range[0]) && isDateBefore(dateToCheck, range[1]);
  }
  if (range && range[0] && hoverDate) {
    return isDateAfter(dateToCheck, range[0]) && isDateBefore(dateToCheck, hoverDate) || isDateBefore(dateToCheck, range[0]) && isDateAfter(dateToCheck, hoverDate);
  }
  return false;
};
const getWeekFromDate = (date, weekStartsOn) => {
  const start = startOfWeek(date, { weekStartsOn });
  const end = endOfWeek(date, { weekStartsOn });
  return [start, end];
};
const matchDate = (date, pattern) => {
  if (Array.isArray(pattern)) {
    return pattern.some((includedDate) => isDateEqual(sanitizeDate(new Date(includedDate)), sanitizeDate(date)));
  }
  return pattern(date);
};
const validateDate = (date, minDate, maxDate, disabledDates, allowedDates, filters, disabledWeekDays, yearRange) => {
  const aboveMax = maxDate ? isDateAfter(sanitizeDate(date), sanitizeDate(maxDate)) : false;
  const bellowMin = minDate ? isDateBefore(sanitizeDate(date), sanitizeDate(minDate)) : false;
  const inDisableArr = matchDate(date, disabledDates);
  const disabledMonths = filters.months.length ? filters.months.map((month) => +month) : [];
  const inDisabledMonths = disabledMonths.includes(getMonth(date));
  const weekDayDisabled = disabledWeekDays.length ? disabledWeekDays.some((day) => +day === getDay(date)) : false;
  const notInSpecific = allowedDates.length ? !allowedDates.some((dateVal) => isDateEqual(sanitizeDate(dateVal), sanitizeDate(date))) : false;
  const dateYear = getYear(date);
  const outOfYearRange = dateYear < +yearRange[0] || dateYear > +yearRange[1];
  return !(aboveMax || bellowMin || inDisableArr || inDisabledMonths || outOfYearRange || weekDayDisabled || notInSpecific);
};
const dateValidator = (minDate, maxDate, disabledDates, allowedDates, filters, disabledWeekDays, yearRange) => {
  const validate = (date) => validateDate(date, minDate, maxDate, disabledDates, allowedDates, filters, disabledWeekDays, yearRange);
  return {
    validate
  };
};
const ariaLabelsKey = Symbol();
const transitionsKey = Symbol();
const autoApplyKey = Symbol();
const textInputKey = Symbol();
const formatLocaleKey = Symbol();
const arrowNavigationKey = Symbol();
const ControlProps = {
  disabled: { type: Boolean, default: false },
  readonly: { type: Boolean, default: false },
  autoApply: { type: Boolean, default: false },
  inline: { type: Boolean, default: false },
  textInput: { type: Boolean, default: false }
};
const SharedProps = {
  range: { type: Boolean, default: false },
  uid: { type: String, default: null }
};
const TimeInputProps = {
  enableSeconds: { type: Boolean, default: false },
  is24: { type: Boolean, default: true },
  noHoursOverlay: { type: Boolean, default: false },
  noMinutesOverlay: { type: Boolean, default: false },
  noSecondsOverlay: { type: Boolean, default: false },
  hoursGridIncrement: { type: [String, Number], default: 1 },
  minutesGridIncrement: { type: [String, Number], default: 5 },
  secondsGridIncrement: { type: [String, Number], default: 5 },
  hoursIncrement: { type: [Number, String], default: 1 },
  minutesIncrement: { type: [Number, String], default: 1 },
  secondsIncrement: { type: [Number, String], default: 1 }
};
const TimePickerProps = {
  ...TimeInputProps,
  fixedStart: { type: Boolean, default: false },
  fixedEnd: { type: Boolean, default: false },
  timePicker: { type: Boolean, default: false }
};
const InputProps = {
  name: { type: String, default: null },
  placeholder: { type: String, default: "" },
  hideInputIcon: { type: Boolean, default: false },
  clearable: { type: Boolean, default: true },
  state: { type: Boolean, default: null },
  required: { type: Boolean, default: false },
  autocomplete: { type: String, default: "off" },
  inputClassName: { type: String, default: null },
  inlineWithInput: { type: Boolean, default: false },
  textInputOptions: { type: Object, default: () => null }
};
const TimeValidationProps = {
  minTime: { type: Object, default: null },
  maxTime: { type: Object, default: null }
};
const DateValidationProps = {
  minDate: { type: [Date, String], default: null },
  maxDate: { type: [Date, String], default: null }
};
const ActionRowProps = {
  selectText: { type: String, default: "Select" },
  cancelText: { type: String, default: "Cancel" },
  previewFormat: {
    type: [String, Function],
    default: () => ""
  },
  multiDates: { type: Boolean, default: false },
  partialRange: { type: Boolean, default: true },
  ...TimeValidationProps
};
const MenuNestedDownProps = {
  monthPicker: { type: Boolean, default: false },
  customProps: { type: Object, default: null },
  yearPicker: { type: Boolean, default: false },
  modelAuto: { type: Boolean, default: false }
};
const CalendarProps = {
  locale: { type: String, default: "en-Us" },
  weekNumName: { type: String, default: "W" },
  weekStart: { type: [Number, String], default: 1 },
  weekNumbers: { type: Boolean, default: false },
  calendarClassName: { type: String, default: null },
  noSwipe: { type: Boolean, default: false },
  monthChangeOnScroll: { type: [Boolean, String], default: true },
  dayNames: {
    type: [Function, Array],
    default: null
  }
};
const MenuProps = {
  ...TimePickerProps,
  ...ActionRowProps,
  ...MenuNestedDownProps,
  ...DateValidationProps,
  ...CalendarProps,
  ...SharedProps,
  vertical: { type: Boolean, default: false },
  disableMonthYearSelect: { type: Boolean, default: false },
  menuClassName: { type: String, default: null },
  yearRange: { type: Array, default: () => [1900, 2100] },
  multiCalendarsSolo: { type: Boolean, default: false },
  calendarCellClassName: { type: String, default: null },
  enableTimePicker: { type: Boolean, default: true },
  autoApply: { type: Boolean, default: false },
  disabledDates: { type: [Array, Function], default: () => [] },
  monthNameFormat: { type: String, default: "short" },
  startDate: { type: [Date, String], default: null },
  startTime: { type: [Object, Array], default: null },
  monthYearComponent: { type: Object, default: null },
  timePickerComponent: { type: Object, default: null },
  actionRowComponent: { type: Object, default: null },
  hideOffsetDates: { type: Boolean, default: false },
  autoRange: { type: [Number, String], default: null },
  noToday: { type: Boolean, default: false },
  disabledWeekDays: { type: Array, default: () => [] },
  allowedDates: { type: Array, default: () => [] },
  showNowButton: { type: Boolean, default: false },
  nowButtonLabel: { type: String, default: "Now" },
  markers: { type: Array, default: () => [] },
  modeHeight: { type: [Number, String], default: 255 },
  escClose: { type: Boolean, default: true },
  spaceConfirm: { type: Boolean, default: true },
  monthChangeOnArrows: { type: Boolean, default: true },
  presetRanges: { type: Array, default: () => [] },
  flow: { type: Array, default: () => [] },
  preventMinMaxNavigation: { type: Boolean, default: false },
  minRange: { type: [Number, String], default: null },
  maxRange: { type: [Number, String], default: null },
  multiDatesLimit: { type: [Number, String], default: null },
  reverseYears: { type: Boolean, default: false },
  keepActionRow: { type: Boolean, default: false },
  weekPicker: { type: Boolean, default: false },
  filters: { type: Object, default: () => ({}) },
  arrowNavigation: { type: Boolean, default: false },
  multiStatic: { type: Boolean, default: true },
  disableTimeRangeValidation: { type: Boolean, default: false },
  highlight: {
    type: [Array, Function],
    default: null
  }
};
const AllProps = {
  ...InputProps,
  ...ControlProps,
  ...MenuProps,
  multiCalendars: { type: [Boolean, Number, String], default: null },
  modelValue: { type: [String, Date, Array, Object, Number], default: null },
  modelType: { type: String, default: null },
  position: { type: String, default: "center" },
  dark: { type: Boolean, default: false },
  format: {
    type: [String, Function],
    default: () => null
  },
  closeOnScroll: { type: Boolean, default: false },
  autoPosition: { type: Boolean, default: true },
  closeOnAutoApply: { type: Boolean, default: true },
  teleport: { type: [String, Object], default: "body" },
  altPosition: { type: [Boolean, Function], default: false },
  transitions: { type: [Boolean, Object], default: true },
  formatLocale: { type: Object, default: null },
  utc: { type: [Boolean, String], default: false },
  ariaLabels: { type: Object, default: () => ({}) }
};
const NestedInternalSharedProps = {
  range: { type: Boolean, default: false },
  multiCalendars: { type: Number, default: 0 },
  internalModelValue: { type: [Date, Array], default: null }
};
const MonthCalendarSharedProps = {
  ...MenuNestedDownProps,
  ...NestedInternalSharedProps,
  vertical: { type: Boolean, default: false },
  month: { type: Number, default: 0 },
  year: { type: Number, default: 0 },
  instance: { type: Number, default: 1 }
};
const _hoisted_1$9 = ["aria-label", "aria-disabled", "aria-readonly"];
const _hoisted_2$7 = {
  key: 1,
  class: "dp__input_wrap"
};
const _hoisted_3$7 = ["id", "name", "placeholder", "disabled", "readonly", "required", "value", "autocomplete", "onKeydown"];
const _hoisted_4$5 = {
  key: 2,
  class: "dp__input_icon"
};
const _hoisted_5$3 = {
  key: 4,
  class: "dp__clear_icon"
};
const _sfc_main$a = /* @__PURE__ */ defineComponent({
  __name: "DatepickerInput",
  props: {
    ...InputProps,
    ...ControlProps,
    ...SharedProps,
    inputValue: { type: String, default: "" },
    inline: { type: Boolean, default: false },
    isMenuOpen: { type: Boolean, default: false },
    pattern: { type: String, default: "" }
  },
  emits: [
    "clear",
    "open",
    "update:inputValue",
    "setInputDate",
    "close",
    "selectDate",
    "setEmptyDate",
    "toggle",
    "focus-prev",
    "focus",
    "blur"
  ],
  setup(__props, { expose, emit }) {
    const props = __props;
    const parsedDate = ref();
    const inputRef = ref(null);
    const isFocused = ref(false);
    const ariaLabels = inject(ariaLabelsKey);
    const inputClass = computed(() => ({
      dp__pointer: !props.disabled && !props.readonly && !props.textInput,
      dp__disabled: props.disabled,
      dp__input_readonly: !props.textInput,
      dp__input: true,
      dp__input_icon_pad: !props.hideInputIcon,
      dp__input_valid: props.state,
      dp__input_invalid: props.state === false,
      dp__input_focus: isFocused.value || props.isMenuOpen,
      dp__input_reg: !props.textInput,
      [props.inputClassName]: !!props.inputClassName
    }));
    const handleInput = (event) => {
      const { value } = event.target;
      const { format: format2, rangeSeparator } = props.textInputOptions;
      if (value !== "") {
        if (props.range) {
          const [dateOne, dateTwo] = value.split(`${rangeSeparator}`);
          if (dateOne && dateTwo) {
            const parsedDateOne = parseFreeInput(dateOne.trim(), format2 || props.pattern);
            const parsedDateTwo = parseFreeInput(dateTwo.trim(), format2 || props.pattern);
            parsedDate.value = parsedDateOne && parsedDateTwo ? [parsedDateOne, parsedDateTwo] : null;
          }
        } else {
          parsedDate.value = parseFreeInput(value, format2 || props.pattern);
        }
        emit("setInputDate", parsedDate.value);
      } else {
        emit("setInputDate", null);
        if (props.autoApply) {
          emit("setEmptyDate");
          parsedDate.value = null;
        }
      }
      emit("update:inputValue", value);
    };
    const handleEnter = () => {
      var _a, _b;
      if (((_a = props.textInputOptions) == null ? void 0 : _a.enterSubmit) && isValidDate(parsedDate.value) && props.inputValue !== "") {
        emit("setInputDate", parsedDate.value, true);
        parsedDate.value = null;
      } else if (((_b = props.textInputOptions) == null ? void 0 : _b.enterSubmit) && props.inputValue === "") {
        parsedDate.value = null;
        emit("clear");
      }
    };
    const handleTab = () => {
      var _a, _b;
      if (((_a = props.textInputOptions) == null ? void 0 : _a.tabSubmit) && isValidDate(parsedDate.value) && props.inputValue !== "") {
        emit("setInputDate", parsedDate.value, true);
        parsedDate.value = null;
      } else if (((_b = props.textInputOptions) == null ? void 0 : _b.tabSubmit) && props.inputValue === "") {
        parsedDate.value = null;
        emit("clear");
      }
    };
    const handleFocus = () => {
      isFocused.value = true;
      emit("focus");
    };
    const handleOpen = () => {
      var _a;
      if (props.textInput && ((_a = props.textInputOptions) == null ? void 0 : _a.openMenu)) {
        if (!props.isMenuOpen) {
          emit("open");
        } else if (props.textInputOptions.enterSubmit) {
          emit("selectDate");
        }
      } else if (!props.textInput) {
        emit("toggle");
      }
    };
    const handleBlur = () => {
      isFocused.value = false;
      if (!props.isMenuOpen) {
        emit("blur");
      }
      if (props.autoApply && props.textInput && parsedDate.value) {
        emit("setInputDate", parsedDate.value);
        emit("selectDate");
        parsedDate.value = null;
      }
    };
    const onClear = () => {
      emit("clear");
    };
    const handleKeyPress = (ev) => {
      if (!props.textInput) {
        ev.preventDefault();
      }
    };
    const focusInput = () => {
      if (inputRef.value) {
        inputRef.value.focus({ preventScroll: true });
      }
    };
    expose({
      focusInput
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        onClick: handleOpen,
        "aria-label": unref(ariaLabels).input,
        role: "textbox",
        "aria-multiline": "false",
        "aria-disabled": _ctx.disabled,
        "aria-readonly": _ctx.readonly
      }, [
        _ctx.$slots.trigger && !_ctx.$slots["dp-input"] && !__props.inline ? renderSlot(_ctx.$slots, "trigger", { key: 0 }) : createCommentVNode("", true),
        !_ctx.$slots.trigger && (!__props.inline || _ctx.inlineWithInput) ? (openBlock(), createElementBlock("div", _hoisted_2$7, [
          _ctx.$slots["dp-input"] && !_ctx.$slots.trigger && !__props.inline ? renderSlot(_ctx.$slots, "dp-input", {
            key: 0,
            value: __props.inputValue,
            onInput: handleInput,
            onEnter: handleEnter,
            onTab: handleTab,
            onClear
          }) : createCommentVNode("", true),
          !_ctx.$slots["dp-input"] ? (openBlock(), createElementBlock("input", {
            key: 1,
            ref_key: "inputRef",
            ref: inputRef,
            id: _ctx.uid ? `dp-input-${_ctx.uid}` : void 0,
            name: _ctx.name,
            class: normalizeClass(unref(inputClass)),
            placeholder: _ctx.placeholder,
            disabled: _ctx.disabled,
            readonly: _ctx.readonly,
            required: _ctx.required,
            value: __props.inputValue,
            autocomplete: _ctx.autocomplete,
            onInput: handleInput,
            onKeydown: [
              withKeys(handleOpen, ["enter"]),
              withKeys(handleTab, ["tab"])
            ],
            onBlur: handleBlur,
            onFocus: handleFocus,
            onKeypress: handleKeyPress
          }, null, 42, _hoisted_3$7)) : createCommentVNode("", true),
          _ctx.$slots["input-icon"] && !_ctx.hideInputIcon ? (openBlock(), createElementBlock("span", _hoisted_4$5, [
            renderSlot(_ctx.$slots, "input-icon")
          ])) : createCommentVNode("", true),
          !_ctx.$slots["input-icon"] && !_ctx.hideInputIcon && !_ctx.$slots["dp-input"] ? (openBlock(), createBlock(unref(CalendarIcon), {
            key: 3,
            class: "dp__input_icon dp__input_icons"
          })) : createCommentVNode("", true),
          _ctx.$slots["clear-icon"] && __props.inputValue && _ctx.clearable && !_ctx.disabled && !_ctx.readonly ? (openBlock(), createElementBlock("span", _hoisted_5$3, [
            renderSlot(_ctx.$slots, "clear-icon", { clear: onClear })
          ])) : createCommentVNode("", true),
          _ctx.clearable && !_ctx.$slots["clear-icon"] && __props.inputValue && !_ctx.disabled && !_ctx.readonly ? (openBlock(), createBlock(unref(CancelIcon), {
            key: 5,
            class: "dp__clear_icon dp__input_icons",
            onClick: withModifiers(onClear, ["stop", "prevent"])
          }, null, 8, ["onClick"])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ], 8, _hoisted_1$9);
    };
  }
});
const getWeekDays = (startDay, month, hideOffsetDates) => {
  const startDate = new Date(JSON.parse(JSON.stringify(startDay)));
  const dates = [];
  for (let i = 0; i < 7; i++) {
    const next = addDays(startDate, i);
    const isNext = getMonth(next) !== month;
    dates.push({
      text: hideOffsetDates && isNext ? "" : next.getDate(),
      value: next,
      current: !isNext
    });
  }
  return dates;
};
const getCalendarDays = (month, year, start, hideOffsetDates) => {
  const weeks = [];
  const firstDate = new Date(year, month);
  const lastDate = new Date(year, month + 1, 0);
  const firstDateInCalendar = startOfWeek(firstDate, { weekStartsOn: start });
  const addDaysToWeek = (date) => {
    const days = getWeekDays(date, month, hideOffsetDates);
    weeks.push({ days });
    if (!weeks[weeks.length - 1].days.some((day) => isDateEqual(resetDateTime(day.value), resetDateTime(lastDate)))) {
      const nextDate = addDays(date, 7);
      addDaysToWeek(nextDate);
    }
  };
  addDaysToWeek(firstDateInCalendar);
  return weeks;
};
const getArrayInArray = (list, increment = 3) => {
  const items = [];
  for (let i = 0; i < list.length; i += increment) {
    items.push([list[i], list[i + 1], list[i + 2]]);
  }
  return items;
};
const getDayNames = (locale, weekStart) => {
  const days = [1, 2, 3, 4, 5, 6, 7].map((day) => {
    return new Intl.DateTimeFormat(locale, { weekday: "short", timeZone: "UTC" }).format(new Date(`2017-01-0${day}T00:00:00+00:00`)).slice(0, 2);
  });
  const beforeWeekStart = days.slice(0, weekStart);
  const afterWeekStart = days.slice(weekStart + 1, days.length);
  return [days[weekStart]].concat(...afterWeekStart).concat(...beforeWeekStart);
};
const getYears = (yearRange) => {
  const years = [];
  for (let year = +yearRange[0]; year <= +yearRange[1]; year++) {
    years.push({ value: +year, text: `${year}` });
  }
  return years;
};
const getMonths = (locale, format2) => {
  const formatter = new Intl.DateTimeFormat(locale, { month: format2, timeZone: "UTC" });
  const months = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map((month) => {
    const mm = month < 10 ? `0${month}` : month;
    return new Date(`2017-${mm}-01T00:00:00+00:00`);
  });
  return months.map((date, i) => ({
    text: formatter.format(date),
    value: i
  }));
};
const hoursToAmPmHours = (index) => {
  const hoursValues = [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
  return hoursValues[index];
};
const getDefaultTextInputOptions = () => ({
  enterSubmit: true,
  tabSubmit: true,
  openMenu: true,
  rangeSeparator: " - "
});
const getDefaultFilters = (filters) => Object.assign({ months: [], years: [], times: { hours: [], minutes: [], seconds: [] } }, filters);
const getKey = (index) => {
  const len = 5;
  function makeKey(length) {
    let result = "";
    const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    const charactersLength = characters.length;
    for (let i = 0; i < length; i++) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result + index;
  }
  return makeKey(len);
};
const unrefElement = (elRef) => {
  var _a;
  const plain = unref(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
};
const getDefaultMarker = (marker) => Object.assign({ type: "dot" }, marker);
const mergeDefaultTransitions = (conf) => Object.assign({
  menuAppear: "dp-menu-appear",
  open: "dp-slide-down",
  close: "dp-slide-up",
  next: "calendar-next",
  previous: "calendar-prev",
  vNext: "dp-slide-up",
  vPrevious: "dp-slide-down"
}, conf);
const defaultAriaLabels = (labels) => {
  return Object.assign({
    toggleOverlay: "Toggle overlay",
    menu: "Datepicker menu",
    input: "Datepicker input",
    calendarWrap: "Calendar wrapper",
    calendarDays: "Calendar days",
    openTimePicker: "Open time picker",
    closeTimePicker: "Close time Picker",
    incrementValue: (type) => `Increment ${type}`,
    decrementValue: (type) => `Decrement ${type}`,
    openTpOverlay: (type) => `Open ${type} overlay`,
    amPmButton: "Switch AM/PM mode",
    openYearsOverlay: "Open years overlay",
    openMonthsOverlay: "Open months overlay",
    nextMonth: "Next month",
    prevMonth: "Previous month"
  }, labels);
};
const isModelAuto = (modelValue) => {
  if (Array.isArray(modelValue)) {
    return !!modelValue[0] && !!modelValue[1];
  }
  return false;
};
const refSets = reactive({
  monthYear: [],
  calendar: [],
  time: [],
  actionRow: [],
  selectionGrid: [],
  timePicker: {
    "0": [],
    "1": []
  },
  monthPicker: []
});
const timePickerBackRef = ref(null);
const isSelectionGrid = ref(false);
const isTimePicker = ref(false);
const isMonthPicker = ref(false);
const isTimePickerMode = ref(false);
const selectedIndex = ref(0);
const activeRow = ref(0);
const useArrowNavigation = () => {
  const matrix = computed(() => {
    return isSelectionGrid.value ? [...refSets.selectionGrid, refSets.actionRow].filter((set2) => set2.length) : isTimePicker.value ? [
      ...refSets.timePicker[0],
      ...refSets.timePicker[1],
      isTimePickerMode.value ? [] : [timePickerBackRef.value],
      refSets.actionRow
    ].filter((set2) => set2.length) : isMonthPicker.value ? [...refSets.monthPicker, refSets.actionRow] : [refSets.monthYear, ...refSets.calendar, refSets.time, refSets.actionRow].filter((set2) => set2.length);
  });
  const handleSelectionIndexX = (increment) => {
    selectedIndex.value = increment ? selectedIndex.value + 1 : selectedIndex.value - 1;
    let el = null;
    if (matrix.value[activeRow.value]) {
      el = matrix.value[activeRow.value][selectedIndex.value];
    }
    if (!el) {
      selectedIndex.value = increment ? selectedIndex.value - 1 : selectedIndex.value + 1;
    }
  };
  const handleSelectionIndexY = (increment) => {
    if (activeRow.value === 0 && !increment || activeRow.value === matrix.value.length && increment)
      return;
    activeRow.value = increment ? activeRow.value + 1 : activeRow.value - 1;
    const el = matrix.value[activeRow.value];
    if (!el) {
      activeRow.value = increment ? activeRow.value - 1 : activeRow.value + 1;
    } else {
      if (matrix.value[activeRow.value] && !matrix.value[activeRow.value][selectedIndex.value] && selectedIndex.value !== 0) {
        selectedIndex.value = matrix.value[activeRow.value].length - 1;
      }
    }
  };
  const handleElFocus = (increment) => {
    let el = null;
    if (matrix.value[activeRow.value]) {
      el = matrix.value[activeRow.value][selectedIndex.value];
    }
    if (el) {
      el.focus({ preventScroll: !isSelectionGrid.value });
    } else {
      selectedIndex.value = increment ? selectedIndex.value - 1 : selectedIndex.value + 1;
    }
  };
  const arrowRight = () => {
    handleSelectionIndexX(true);
    handleElFocus(true);
  };
  const arrowLeft = () => {
    handleSelectionIndexX(false);
    handleElFocus(false);
  };
  const arrowUp = () => {
    handleSelectionIndexY(false);
    handleElFocus(true);
  };
  const arrowDown = () => {
    handleSelectionIndexY(true);
    handleElFocus(true);
  };
  const buildMatrix = (elements, set2) => {
    refSets[set2] = elements;
  };
  const buildMultiLevelMatrix = (elements, set2) => {
    refSets[set2] = elements;
  };
  const resetNavigation = () => {
    selectedIndex.value = 0;
    activeRow.value = 0;
  };
  const setMonthPicker = (value) => {
    isMonthPicker.value = value;
    resetNavigation();
  };
  const setSelectionGrid = (value) => {
    isSelectionGrid.value = value;
    resetNavigation();
    if (!value) {
      refSets.selectionGrid = [];
    }
  };
  const setTimePicker = (value, mode = false) => {
    isTimePicker.value = value;
    isTimePickerMode.value = mode;
    resetNavigation();
    if (!value) {
      refSets.timePicker[0] = [];
      refSets.timePicker[1] = [];
    }
  };
  const setTimePickerElements = (elements, order = 0) => {
    refSets.timePicker[order] = elements;
  };
  const setTimePickerBackRef = (el) => {
    timePickerBackRef.value = el;
  };
  const clearArrowNav = () => {
    refSets.monthYear = [];
    refSets.calendar = [];
    refSets.time = [];
    refSets.actionRow = [];
    refSets.selectionGrid = [];
    refSets.timePicker[0] = [];
    refSets.timePicker[1] = [];
    isSelectionGrid.value = false;
    isTimePicker.value = false;
    isTimePickerMode.value = false;
    isMonthPicker.value = false;
    resetNavigation();
    timePickerBackRef.value = null;
  };
  return {
    buildMatrix,
    buildMultiLevelMatrix,
    setTimePickerBackRef,
    setSelectionGrid,
    setTimePicker,
    setTimePickerElements,
    arrowRight,
    arrowLeft,
    arrowUp,
    arrowDown,
    clearArrowNav,
    setMonthPicker
  };
};
const _hoisted_1$8 = ["aria-label"];
const _hoisted_2$6 = {
  class: "dp__calendar_header",
  role: "row"
};
const _hoisted_3$6 = {
  key: 0,
  class: "dp__calendar_header_item",
  role: "gridcell"
};
const _hoisted_4$4 = /* @__PURE__ */ createElementVNode("div", { class: "dp__calendar_header_separator" }, null, -1);
const _hoisted_5$2 = ["aria-label"];
const _hoisted_6$1 = {
  key: 0,
  role: "gridcell",
  class: "dp__calendar_item dp__week_num"
};
const _hoisted_7$1 = { class: "dp__cell_inner" };
const _hoisted_8 = ["aria-selected", "aria-disabled", "onClick", "onKeydown", "onMouseover"];
const _hoisted_9 = /* @__PURE__ */ createElementVNode("div", { class: "dp__arrow_bottom_tp" }, null, -1);
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  __name: "Calendar",
  props: {
    ...MonthCalendarSharedProps,
    ...CalendarProps,
    mappedDates: { type: Array, default: () => [] },
    getWeekNum: {
      type: Function,
      default: () => ""
    },
    modeHeight: { type: [Number, String], default: 255 },
    specificMode: { type: Boolean, default: false }
  },
  emits: ["selectDate", "setHoverDate", "handleScroll", "mount", "handleSwipe"],
  setup(__props, { expose, emit }) {
    const props = __props;
    const showMakerTooltip = ref(null);
    const markerTooltipStyle = ref({ bottom: "", left: "", transform: "" });
    const dayRefs = ref([]);
    const calendarWrapRef = ref(null);
    const showCalendar = ref(true);
    const transitions = inject(transitionsKey);
    const ariaLabels = inject(ariaLabelsKey);
    const arrowNavigation = inject(arrowNavigationKey);
    const transitionName = ref("");
    const touch = ref({ startX: 0, endX: 0, startY: 0, endY: 0 });
    const weekDays = computed(() => {
      return props.dayNames ? Array.isArray(props.dayNames) ? props.dayNames : props.dayNames(props.locale, +props.weekStart) : getDayNames(props.locale, +props.weekStart);
    });
    const { buildMultiLevelMatrix } = useArrowNavigation();
    onMounted(() => {
      emit("mount", { cmp: "calendar", refs: dayRefs });
      if (!props.noSwipe) {
        if (calendarWrapRef.value) {
          calendarWrapRef.value.addEventListener("touchstart", onTouchStart, { passive: false });
          calendarWrapRef.value.addEventListener("touchend", onTouchEnd, { passive: false });
          calendarWrapRef.value.addEventListener("touchmove", onTouchMove, { passive: false });
        }
      }
      if (props.monthChangeOnScroll && calendarWrapRef.value) {
        calendarWrapRef.value.addEventListener("wheel", onScroll, { passive: false });
      }
    });
    const triggerTransition = (month, year) => {
      if (transitions == null ? void 0 : transitions.value) {
        const newDate = resetDateTime(setDateMonthOrYear(new Date(), props.month, props.year));
        transitionName.value = isDateAfter(resetDateTime(setDateMonthOrYear(new Date(), month, year)), newDate) ? transitions.value[props.vertical ? "vNext" : "next"] : transitions.value[props.vertical ? "vPrevious" : "previous"];
        showCalendar.value = false;
        nextTick(() => {
          showCalendar.value = true;
        });
      }
    };
    const calendarWrapClass = computed(() => ({
      dp__calendar_wrap: true,
      [props.calendarClassName]: !!props.calendarClassName
    }));
    const markerClass = computed(() => (marker) => {
      const defaultMarker = getDefaultMarker(marker);
      return {
        dp__marker_dot: defaultMarker.type === "dot",
        dp__marker_line: defaultMarker.type === "line"
      };
    });
    const dateMatch = computed(() => (day) => isDateEqual(day, showMakerTooltip.value));
    const calendarParentClass = computed(() => ({
      dp__calendar: true,
      dp__calendar_next: props.multiCalendars > 0 && props.instance !== 0
    }));
    const contentWrapStyle = computed(() => props.specificMode ? { height: `${props.modeHeight}px` } : null);
    const onMouseOver = (day, weekInd, dayInd) => {
      var _a, _b;
      emit("setHoverDate", day);
      if ((_b = (_a = day.marker) == null ? void 0 : _a.tooltip) == null ? void 0 : _b.length) {
        const el = unrefElement(dayRefs.value[weekInd][dayInd]);
        if (el) {
          const { width, height } = el.getBoundingClientRect();
          markerTooltipStyle.value = {
            bottom: `${height}px`,
            left: `${width / 2}px`,
            transform: `translateX(-50%)`
          };
          showMakerTooltip.value = day.value;
        }
      }
    };
    const onMouseLeave = () => {
      showMakerTooltip.value = null;
    };
    const onTouchStart = (ev) => {
      touch.value.startX = ev.changedTouches[0].screenX;
      touch.value.startY = ev.changedTouches[0].screenY;
    };
    const onTouchEnd = (ev) => {
      touch.value.endX = ev.changedTouches[0].screenX;
      touch.value.endY = ev.changedTouches[0].screenY;
      handleTouch();
    };
    const onTouchMove = (ev) => {
      ev.preventDefault();
    };
    const handleTouch = () => {
      const property = props.vertical ? "Y" : "X";
      if (Math.abs(touch.value[`start${property}`] - touch.value[`end${property}`]) > 10) {
        emit("handleSwipe", touch.value[`start${property}`] > touch.value[`end${property}`] ? "right" : "left");
      }
    };
    const assignDayRef = (el, weekInd, dayInd) => {
      if (el) {
        if (Array.isArray(dayRefs.value[weekInd])) {
          dayRefs.value[weekInd][dayInd] = el;
        } else {
          dayRefs.value[weekInd] = [el];
        }
      }
      if (arrowNavigation == null ? void 0 : arrowNavigation.value) {
        buildMultiLevelMatrix(dayRefs.value, "calendar");
      }
    };
    const onScroll = (ev) => {
      if (props.monthChangeOnScroll) {
        ev.preventDefault();
        emit("handleScroll", ev);
      }
    };
    expose({ triggerTransition });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(unref(calendarParentClass))
      }, [
        createElementVNode("div", {
          style: normalizeStyle(unref(contentWrapStyle))
        }, [
          !__props.specificMode ? (openBlock(), createElementBlock("div", {
            key: 0,
            ref_key: "calendarWrapRef",
            ref: calendarWrapRef,
            class: normalizeClass(unref(calendarWrapClass)),
            role: "grid",
            "aria-label": unref(ariaLabels).calendarWrap
          }, [
            createElementVNode("div", _hoisted_2$6, [
              _ctx.weekNumbers ? (openBlock(), createElementBlock("div", _hoisted_3$6, toDisplayString(_ctx.weekNumName), 1)) : createCommentVNode("", true),
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(weekDays), (dayVal, i) => {
                return openBlock(), createElementBlock("div", {
                  class: "dp__calendar_header_item",
                  role: "gridcell",
                  key: i
                }, [
                  _ctx.$slots["calendar-header"] ? renderSlot(_ctx.$slots, "calendar-header", {
                    key: 0,
                    day: dayVal,
                    index: i
                  }) : createCommentVNode("", true),
                  !_ctx.$slots["calendar-header"] ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    createTextVNode(toDisplayString(dayVal), 1)
                  ], 64)) : createCommentVNode("", true)
                ]);
              }), 128))
            ]),
            _hoisted_4$4,
            createVNode(Transition, {
              name: transitionName.value,
              css: !!unref(transitions)
            }, {
              default: withCtx(() => [
                showCalendar.value ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: "dp__calendar",
                  role: "grid",
                  "aria-label": unref(ariaLabels).calendarDays
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(__props.mappedDates, (week, weekInd) => {
                    return openBlock(), createElementBlock("div", {
                      class: "dp__calendar_row",
                      role: "row",
                      key: weekInd
                    }, [
                      _ctx.weekNumbers ? (openBlock(), createElementBlock("div", _hoisted_6$1, [
                        createElementVNode("div", _hoisted_7$1, toDisplayString(__props.getWeekNum(week.days)), 1)
                      ])) : createCommentVNode("", true),
                      (openBlock(true), createElementBlock(Fragment, null, renderList(week.days, (dayVal, dayInd) => {
                        return openBlock(), createElementBlock("div", {
                          role: "gridcell",
                          class: "dp__calendar_item",
                          ref_for: true,
                          ref: (el) => assignDayRef(el, weekInd, dayInd),
                          key: dayInd + weekInd,
                          "aria-selected": dayVal.classData.dp__active_date || dayVal.classData.dp__range_start || dayVal.classData.dp__range_start,
                          "aria-disabled": dayVal.classData.dp__cell_disabled,
                          tabindex: "0",
                          onClick: withModifiers(($event) => _ctx.$emit("selectDate", dayVal), ["stop", "prevent"]),
                          onKeydown: withKeys(($event) => _ctx.$emit("selectDate", dayVal), ["enter"]),
                          onMouseover: ($event) => onMouseOver(dayVal, weekInd, dayInd),
                          onMouseleave: onMouseLeave
                        }, [
                          createElementVNode("div", {
                            class: normalizeClass(["dp__cell_inner", dayVal.classData])
                          }, [
                            _ctx.$slots.day ? renderSlot(_ctx.$slots, "day", {
                              key: 0,
                              day: +dayVal.text,
                              date: dayVal.value
                            }) : createCommentVNode("", true),
                            !_ctx.$slots.day ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                              createTextVNode(toDisplayString(dayVal.text), 1)
                            ], 64)) : createCommentVNode("", true),
                            dayVal.marker ? (openBlock(), createElementBlock("div", {
                              key: 2,
                              class: normalizeClass(unref(markerClass)(dayVal.marker)),
                              style: normalizeStyle(dayVal.marker.color ? { backgroundColor: dayVal.marker.color } : {})
                            }, null, 6)) : createCommentVNode("", true),
                            unref(dateMatch)(dayVal.value) ? (openBlock(), createElementBlock("div", {
                              key: 3,
                              class: "dp__marker_tooltip",
                              style: normalizeStyle(markerTooltipStyle.value)
                            }, [
                              createElementVNode("div", {
                                class: "dp__tooltip_content",
                                onClick: _cache[0] || (_cache[0] = withModifiers(() => {
                                }, ["stop"]))
                              }, [
                                (openBlock(true), createElementBlock(Fragment, null, renderList(dayVal.marker.tooltip, (tooltip, i) => {
                                  return openBlock(), createElementBlock("div", {
                                    key: i,
                                    class: "dp__tooltip_text"
                                  }, [
                                    _ctx.$slots["marker-tooltip"] ? renderSlot(_ctx.$slots, "marker-tooltip", {
                                      key: 0,
                                      tooltop: tooltip,
                                      day: dayVal.value
                                    }) : createCommentVNode("", true),
                                    !_ctx.$slots["marker-tooltip"] ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                                      createElementVNode("div", {
                                        class: "dp__tooltip_mark",
                                        style: normalizeStyle(tooltip.color ? { backgroundColor: tooltip.color } : {})
                                      }, null, 4),
                                      createElementVNode("div", null, toDisplayString(tooltip.text), 1)
                                    ], 64)) : createCommentVNode("", true)
                                  ]);
                                }), 128)),
                                _hoisted_9
                              ])
                            ], 4)) : createCommentVNode("", true)
                          ], 2)
                        ], 40, _hoisted_8);
                      }), 128))
                    ]);
                  }), 128))
                ], 8, _hoisted_5$2)) : createCommentVNode("", true)
              ]),
              _: 3
            }, 8, ["name", "css"])
          ], 10, _hoisted_1$8)) : createCommentVNode("", true)
        ], 4)
      ], 2);
    };
  }
});
const isTime = (value) => {
  return typeof value === "object";
};
const modelValueIsRange = (modelValue, range) => {
  return range;
};
const isTimeArray = (value) => {
  return Array.isArray(value) && value.length === 2;
};
const isMonthArray = (value) => {
  return Array.isArray(value);
};
const isMonth = (value) => {
  return typeof value === "object";
};
const isModelValueRange = (value) => {
  return Array.isArray(value);
};
const isNumberArray = (value) => {
  return Array.isArray(value);
};
const isRange = (value) => {
  return Array.isArray(value) && value.length === 2;
};
const isRangeArray = (value, partialRange) => {
  if (partialRange)
    return Array.isArray(value);
  return isRange(value);
};
const isTimeArr = (value) => {
  return Array.isArray(value);
};
const isSingle = (value) => {
  return typeof value === "string" || typeof value === "object" || typeof value === "number";
};
const isString = (value) => {
  return typeof value === "string";
};
const _hoisted_1$7 = { class: "dp__selection_preview" };
const _hoisted_2$5 = { class: "dp__action_buttons" };
const _hoisted_3$5 = ["onKeydown"];
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  __name: "ActionRow",
  props: {
    ...ActionRowProps,
    ...DateValidationProps,
    ...TimeValidationProps,
    ...MenuNestedDownProps,
    ...NestedInternalSharedProps,
    inline: { type: Boolean, default: false },
    timePicker: { type: Boolean, default: false },
    calendarWidth: { type: Number, default: 0 },
    menuMount: { type: Boolean, default: false },
    enableTimePicker: { type: Boolean, default: true }
  },
  emits: ["closePicker", "selectDate"],
  setup(__props, { emit }) {
    const props = __props;
    const { buildMatrix } = useArrowNavigation();
    const formatLocale = inject(formatLocaleKey);
    const arrowNavigation = inject(arrowNavigationKey);
    const cancelButtonRef = ref(null);
    const selectButtonRef = ref(null);
    onMounted(() => {
      if (arrowNavigation == null ? void 0 : arrowNavigation.value) {
        buildMatrix([unrefElement(cancelButtonRef), unrefElement(selectButtonRef)], "actionRow");
      }
    });
    const validDateRange = computed(() => {
      return props.range && !props.partialRange && props.internalModelValue ? props.internalModelValue.length === 2 : true;
    });
    const selectClass = computed(() => ({
      dp__action: true,
      dp__select: true,
      dp__action_disabled: !isTimeValid.value || !isMonthValid.value || !validDateRange.value
    }));
    const isTimeValid = computed(() => {
      if (!props.enableTimePicker)
        return true;
      return isValidTime(props.internalModelValue, props.maxTime, props.minTime, props.maxDate, props.minDate);
    });
    const isMonthValid = computed(() => {
      if (!props.monthPicker)
        return true;
      return isMonthWithinRange(props.internalModelValue, props.minDate, props.maxDate);
    });
    const formatWrap = (date) => {
      return formatDate(date, props.previewFormat, formatLocale == null ? void 0 : formatLocale.value);
    };
    const previewValue = computed(() => {
      if (!props.internalModelValue || !props.menuMount)
        return "";
      if (typeof props.previewFormat === "string") {
        if (isModelValueRange(props.internalModelValue)) {
          if (props.internalModelValue.length === 2 && props.internalModelValue[1]) {
            if (props.multiCalendars > 0) {
              return `${formatWrap(props.internalModelValue[0])} - ${formatWrap(props.internalModelValue[1])}`;
            }
            return [formatWrap(props.internalModelValue[0]), formatWrap(props.internalModelValue[1])];
          }
          if (props.multiDates) {
            return props.internalModelValue.map((date) => `${formatWrap(date)}`);
          }
          if (props.modelAuto) {
            return `${formatWrap(props.internalModelValue[0])}`;
          }
          return `${formatWrap(props.internalModelValue[0])} -`;
        }
        return formatDate(props.internalModelValue, props.previewFormat, formatLocale == null ? void 0 : formatLocale.value);
      }
      if (props.timePicker) {
        return props.previewFormat(getTImeForExternal(props.internalModelValue));
      }
      if (props.monthPicker) {
        return props.previewFormat(getMonthVal(props.internalModelValue));
      }
      return props.previewFormat(props.internalModelValue);
    });
    const selectDate = () => {
      if (isTimeValid.value && isMonthValid.value) {
        emit("selectDate");
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "dp__action_row",
        style: normalizeStyle(__props.calendarWidth ? { width: `${__props.calendarWidth}px` } : {})
      }, [
        createElementVNode("div", _hoisted_1$7, [
          _ctx.$slots["action-preview"] ? renderSlot(_ctx.$slots, "action-preview", {
            key: 0,
            value: _ctx.internalModelValue
          }) : createCommentVNode("", true),
          !_ctx.$slots["action-preview"] ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            !Array.isArray(unref(previewValue)) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createTextVNode(toDisplayString(unref(previewValue)), 1)
            ], 64)) : createCommentVNode("", true),
            Array.isArray(unref(previewValue)) ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(unref(previewValue), (preview, i) => {
              return openBlock(), createElementBlock("div", { key: i }, toDisplayString(preview), 1);
            }), 128)) : createCommentVNode("", true)
          ], 64)) : createCommentVNode("", true)
        ]),
        createElementVNode("div", _hoisted_2$5, [
          _ctx.$slots["action-select"] ? renderSlot(_ctx.$slots, "action-select", {
            key: 0,
            value: _ctx.internalModelValue
          }) : createCommentVNode("", true),
          !_ctx.$slots["action-select"] ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            !__props.inline ? (openBlock(), createElementBlock("span", {
              key: 0,
              class: "dp__action dp__cancel",
              ref_key: "cancelButtonRef",
              ref: cancelButtonRef,
              tabindex: "0",
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("closePicker")),
              onKeydown: _cache[1] || (_cache[1] = withKeys(($event) => _ctx.$emit("closePicker"), ["enter"]))
            }, toDisplayString(_ctx.cancelText), 545)) : createCommentVNode("", true),
            createElementVNode("span", {
              class: normalizeClass(unref(selectClass)),
              tabindex: "0",
              onKeydown: withKeys(selectDate, ["enter"]),
              onClick: selectDate,
              ref_key: "selectButtonRef",
              ref: selectButtonRef
            }, toDisplayString(_ctx.selectText), 43, _hoisted_3$5)
          ], 64)) : createCommentVNode("", true)
        ])
      ], 4);
    };
  }
});
const _hoisted_1$6 = { class: "dp__selection_grid_header" };
const _hoisted_2$4 = ["aria-selected", "aria-disabled", "onClick", "onKeydown", "onMouseover"];
const _hoisted_3$4 = ["aria-label", "onKeydown"];
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  __name: "SelectionGrid",
  props: {
    items: { type: Array, default: () => [] },
    modelValue: { type: [String, Number], default: null },
    multiModelValue: { type: Array, default: () => [] },
    disabledValues: { type: Array, default: () => [] },
    minValue: { type: [Number, String], default: null },
    maxValue: { type: [Number, String], default: null },
    year: { type: Number, default: 0 },
    skipActive: { type: Boolean, default: false },
    headerRefs: { type: Array, default: () => [] },
    skipButtonRef: { type: Boolean, default: false },
    monthPicker: { type: Boolean, default: false },
    yearPicker: { type: Boolean, default: false }
  },
  emits: ["update:modelValue", "selected", "toggle", "reset-flow"],
  setup(__props, { expose, emit }) {
    const props = __props;
    const scrollable = ref(false);
    const selectionActiveRef = ref(null);
    const gridWrapRef = ref(null);
    const elementRefs = ref([]);
    const autoApply = inject(autoApplyKey, false);
    const textInput = inject(textInputKey, ref(false));
    const ariaLabels = inject(ariaLabelsKey);
    const arrowNavigation = inject(arrowNavigationKey);
    const hoverValue = ref();
    const toggleButton = ref();
    const { setSelectionGrid, buildMultiLevelMatrix, setMonthPicker } = useArrowNavigation();
    onBeforeUpdate(() => {
      selectionActiveRef.value = null;
    });
    onMounted(() => {
      nextTick().then(() => setScrollPosition());
      focusGrid();
      handleArrowNav(true);
    });
    onUnmounted(() => handleArrowNav(false));
    const handleArrowNav = (value) => {
      var _a;
      if (arrowNavigation == null ? void 0 : arrowNavigation.value) {
        if ((_a = props.headerRefs) == null ? void 0 : _a.length) {
          setMonthPicker(value);
        } else {
          setSelectionGrid(value);
        }
      }
    };
    const focusGrid = () => {
      const elm = unrefElement(gridWrapRef);
      if (elm) {
        if (!textInput.value) {
          elm.focus({ preventScroll: true });
        }
        scrollable.value = elm.clientHeight < elm.scrollHeight;
      }
    };
    const dpOverlayClass = computed(() => ({
      dp__overlay: true
    }));
    const cellClassName = computed(() => ({
      dp__overlay_col: true
    }));
    const mappedItems = computed(() => {
      return props.items.map((item) => {
        return item.filter((exists) => exists).map((itemVal) => {
          var _a, _b, _c;
          const disabled = props.disabledValues.some((val) => val === itemVal.value) || checkMinMaxValue(itemVal.value);
          const active = ((_a = props.multiModelValue) == null ? void 0 : _a.length) ? (_b = props.multiModelValue) == null ? void 0 : _b.some((value) => isDateEqual(value, setYear(props.monthPicker ? setMonth(new Date(), itemVal.value) : new Date(), props.monthPicker ? props.year : itemVal.value))) : props.skipActive ? false : itemVal.value === props.modelValue;
          return {
            ...itemVal,
            className: {
              dp__overlay_cell_active: active,
              dp__overlay_cell: !active,
              dp__overlay_cell_disabled: disabled,
              dp__overlay_cell_active_disabled: disabled && active,
              dp__overlay_cell_pad: true,
              dp__cell_in_between: ((_c = props.multiModelValue) == null ? void 0 : _c.length) ? rangeActive(itemVal.value) : false
            }
          };
        });
      });
    });
    const actionButtonClass = computed(() => ({
      dp__button: true,
      dp__overlay_action: true,
      dp__over_action_scroll: scrollable.value,
      dp__button_bottom: autoApply
    }));
    const containerClass = computed(() => {
      var _a, _b;
      return {
        dp__overlay_container: true,
        dp__container_flex: ((_a = props.items) == null ? void 0 : _a.length) <= 6,
        dp__container_block: ((_b = props.items) == null ? void 0 : _b.length) > 6
      };
    });
    const checkMinMaxValue = (value) => {
      const hasMax = props.maxValue || props.maxValue === 0;
      const hasMin = props.minValue || props.minValue === 0;
      if (!hasMax && !hasMin)
        return false;
      if (hasMax && hasMin) {
        return +value > +props.maxValue || +value < +props.minValue;
      }
      if (hasMax) {
        return +value > +props.maxValue;
      }
      if (hasMin) {
        return +value < +props.minValue;
      }
      return false;
    };
    const setScrollPosition = () => {
      const el = unrefElement(selectionActiveRef);
      if (el) {
        const parent = unrefElement(gridWrapRef);
        if (parent) {
          parent.scrollTop = el.offsetTop - parent.offsetTop - (parent.getBoundingClientRect().height / 2 - el.getBoundingClientRect().height);
        }
      }
    };
    const onClick = (val) => {
      if (!props.disabledValues.some((value) => value === val) && !checkMinMaxValue(val)) {
        emit("update:modelValue", val);
        emit("selected");
      }
    };
    const rangeActive = (value) => {
      const yearValue = props.monthPicker ? props.year : value;
      return isDateBetween(props.multiModelValue, setYear(props.monthPicker ? setMonth(new Date(), hoverValue.value || 0) : new Date(), props.monthPicker ? yearValue : hoverValue.value || yearValue), setYear(props.monthPicker ? setMonth(new Date(), value) : new Date(), yearValue));
    };
    const toggle = () => {
      emit("toggle");
      emit("reset-flow");
    };
    const assignRef = (el, col, rowInd, colInd) => {
      var _a, _b;
      if (el) {
        if (col.value === +props.modelValue && !props.disabledValues.includes(col.value)) {
          selectionActiveRef.value = el;
        }
        if (arrowNavigation == null ? void 0 : arrowNavigation.value) {
          if (Array.isArray(elementRefs.value[rowInd])) {
            elementRefs.value[rowInd][colInd] = el;
          } else {
            elementRefs.value[rowInd] = [el];
          }
          const refs = ((_a = props.headerRefs) == null ? void 0 : _a.length) ? [props.headerRefs].concat(elementRefs.value) : elementRefs.value.concat([props.skipButtonRef ? [] : [toggleButton.value]]);
          buildMultiLevelMatrix(refs, ((_b = props.headerRefs) == null ? void 0 : _b.length) ? "monthPicker" : "selectionGrid");
        }
      }
    };
    expose({ focusGrid });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "gridWrapRef",
        ref: gridWrapRef,
        class: normalizeClass(unref(dpOverlayClass)),
        role: "dialog",
        tabindex: "0"
      }, [
        createElementVNode("div", {
          class: normalizeClass(unref(containerClass)),
          role: "grid"
        }, [
          createElementVNode("div", _hoisted_1$6, [
            renderSlot(_ctx.$slots, "header")
          ]),
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(mappedItems), (row, i) => {
            return openBlock(), createElementBlock("div", {
              class: "dp__overlay_row",
              key: unref(getKey)(i),
              role: "row"
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(row, (col, ind) => {
                return openBlock(), createElementBlock("div", {
                  role: "gridcell",
                  class: normalizeClass(unref(cellClassName)),
                  key: col.value,
                  "aria-selected": col.value === __props.modelValue && !__props.disabledValues.includes(col.value),
                  "aria-disabled": col.className.dp__overlay_cell_disabled,
                  ref_for: true,
                  ref: (el) => assignRef(el, col, i, ind),
                  tabindex: "0",
                  onClick: ($event) => onClick(col.value),
                  onKeydown: withKeys(($event) => onClick(col.value), ["enter"]),
                  onMouseover: ($event) => hoverValue.value = col.value
                }, [
                  createElementVNode("div", {
                    class: normalizeClass(col.className)
                  }, [
                    _ctx.$slots.item ? renderSlot(_ctx.$slots, "item", {
                      key: 0,
                      item: col
                    }) : createCommentVNode("", true),
                    !_ctx.$slots.item ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                      createTextVNode(toDisplayString(col.text), 1)
                    ], 64)) : createCommentVNode("", true)
                  ], 2)
                ], 42, _hoisted_2$4);
              }), 128))
            ]);
          }), 128)),
          _ctx.$slots["button-icon"] ? (openBlock(), createElementBlock("div", {
            key: 0,
            role: "button",
            "aria-label": unref(ariaLabels).toggleOverlay,
            class: normalizeClass(unref(actionButtonClass)),
            tabindex: "0",
            ref_key: "toggleButton",
            ref: toggleButton,
            onClick: toggle,
            onKeydown: withKeys(toggle, ["enter"])
          }, [
            renderSlot(_ctx.$slots, "button-icon")
          ], 42, _hoisted_3$4)) : createCommentVNode("", true)
        ], 2)
      ], 2);
    };
  }
});
const useTransitions = () => {
  const transitions = inject(transitionsKey);
  const transitionName = computed(() => (isOpen) => {
    if (transitions == null ? void 0 : transitions.value) {
      return isOpen ? transitions.value.open : transitions.value.close;
    }
    return "";
  });
  return { transitionName, showTransition: !!(transitions == null ? void 0 : transitions.value) };
};
const _hoisted_1$5 = {
  key: 0,
  class: "dp__time_input"
};
const _hoisted_2$3 = /* @__PURE__ */ createTextVNode(" : ");
const _hoisted_3$3 = ["aria-label", "onKeydown", "onClick"];
const _hoisted_4$3 = ["aria-label", "onKeydown", "onClick"];
const _hoisted_5$1 = ["aria-label", "onKeydown", "onClick"];
const _hoisted_6 = { key: 0 };
const _hoisted_7 = ["aria-label", "onKeydown"];
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  __name: "TimeInput",
  props: {
    ...TimeInputProps,
    hours: { type: Number, default: 0 },
    minutes: { type: Number, default: 0 },
    seconds: { type: Number, default: 0 },
    filters: { type: Object, default: () => ({}) },
    disabled: { type: Boolean, default: false },
    closeTimePickerBtn: { type: Object, default: null },
    order: { type: Number, default: 0 }
  },
  emits: [
    "setHours",
    "setMinutes",
    "update:hours",
    "update:minutes",
    "update:seconds",
    "reset-flow",
    "mounted",
    "overlay-closed"
  ],
  setup(__props, { expose, emit }) {
    const props = __props;
    const overlays = reactive({
      hours: false,
      minutes: false,
      seconds: false
    });
    const amPm = ref("AM");
    const amPmButton = ref(null);
    const ariaLabels = inject(ariaLabelsKey);
    const arrowNavigation = inject(arrowNavigationKey);
    const elementRefs = ref([]);
    const { transitionName, showTransition } = useTransitions();
    const { setTimePickerElements, setTimePickerBackRef } = useArrowNavigation();
    onMounted(() => {
      emit("mounted");
    });
    const timeColClass = computed(() => ({
      dp__time_col: true,
      dp__time_col_reg: !props.enableSeconds && props.is24,
      dp__time_col_reg_with_button: !props.enableSeconds && !props.is24,
      dp__time_col_sec: props.enableSeconds && props.is24,
      dp__time_col_sec_with_button: props.enableSeconds && !props.is24
    }));
    const timeInputs = computed(() => {
      const inputs = [{ type: "hours" }, "separator", { type: "minutes" }];
      return props.enableSeconds ? inputs.concat(["separator", { type: "seconds" }]) : inputs;
    });
    const timeInputOverlays = computed(() => timeInputs.value.filter((input) => typeof input !== "string"));
    const timeValueDisplay = computed(() => (type) => {
      if (type === "hours") {
        const hour = convert24ToAmPm(props.hours);
        return { text: hour < 10 ? `0${hour}` : `${hour}`, value: hour };
      }
      return { text: props[type] < 10 ? `0${props[type]}` : `${props[type]}`, value: props[type] };
    });
    const getGridItems = (type) => {
      const max = type === "hours" ? props.is24 ? 24 : 12 : 60;
      const increment = +props[`${type}GridIncrement`];
      const generatedArray = [];
      for (let i = 0; i < max; i += increment) {
        generatedArray.push({ value: i, text: i < 10 ? `0${i}` : `${i}` });
      }
      return getArrayInArray(generatedArray);
    };
    const checkOverlayDisabled = (type) => {
      return props[`no${type[0].toUpperCase() + type.slice(1)}Overlay`];
    };
    const toggleOverlay = (type) => {
      if (!checkOverlayDisabled(type)) {
        overlays[type] = !overlays[type];
        if (!overlays[type]) {
          emit("overlay-closed");
        }
      }
    };
    const handleTimeValue = (type, inc = true) => {
      const method = type === "hours" ? getHours : type === "minutes" ? getMinutes : getSeconds;
      const addOrSub = inc ? addTime : subTime;
      emit(`update:${type}`, method(addOrSub({ [type]: +props[type] }, { [type]: +props[`${type}Increment`] })));
    };
    const convert24ToAmPm = (time) => {
      if (props.is24) {
        return time;
      }
      if (time >= 12) {
        amPm.value = "PM";
      } else {
        amPm.value = "AM";
      }
      return hoursToAmPmHours(time);
    };
    const setAmPm = () => {
      if (amPm.value === "PM") {
        amPm.value = "AM";
        emit("update:hours", props.hours - 12);
      } else {
        amPm.value = "PM";
        emit("update:hours", props.hours + 12);
      }
    };
    const openChildCmp = (child) => {
      overlays[child] = true;
    };
    const assignRefs = (el, col, pos) => {
      if (el && (arrowNavigation == null ? void 0 : arrowNavigation.value)) {
        if (Array.isArray(elementRefs.value[col])) {
          elementRefs.value[col][pos] = el;
        } else {
          elementRefs.value[col] = [el];
        }
        const matrix = elementRefs.value.reduce((col2, row) => row.map((_, i) => [...col2[i] || [], row[i]]), []);
        setTimePickerBackRef(props.closeTimePickerBtn);
        if (amPmButton.value) {
          matrix[1] = matrix[1].concat(amPmButton.value);
        }
        setTimePickerElements(matrix, props.order);
      }
    };
    const handleTimeFromOverlay = (type, value) => {
      if (type === "hours" && !props.is24) {
        return emit(`update:${type}`, amPm.value === "PM" ? value + 12 : value);
      }
      return emit(`update:${type}`, value);
    };
    expose({ openChildCmp });
    return (_ctx, _cache) => {
      return !__props.disabled ? (openBlock(), createElementBlock("div", _hoisted_1$5, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(timeInputs), (timeInput, i) => {
          return openBlock(), createElementBlock("div", {
            key: i,
            class: normalizeClass(unref(timeColClass))
          }, [
            timeInput === "separator" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              _hoisted_2$3
            ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createElementVNode("div", {
                class: "dp__inc_dec_button",
                role: "button",
                "aria-label": unref(ariaLabels).incrementValue(timeInput.type),
                tabindex: "0",
                onKeydown: withKeys(($event) => handleTimeValue(timeInput.type), ["enter"]),
                onClick: ($event) => handleTimeValue(timeInput.type),
                ref_for: true,
                ref: (el) => assignRefs(el, i, 0)
              }, [
                _ctx.$slots["arrow-up"] ? renderSlot(_ctx.$slots, "arrow-up", { key: 0 }) : createCommentVNode("", true),
                !_ctx.$slots["arrow-up"] ? (openBlock(), createBlock(unref(ChevronUpIcon), { key: 1 })) : createCommentVNode("", true)
              ], 40, _hoisted_3$3),
              createElementVNode("div", {
                role: "button",
                "aria-label": unref(ariaLabels).openTpOverlay(timeInput.type),
                class: normalizeClass(checkOverlayDisabled(timeInput.type) ? "" : "dp__time_display"),
                tabindex: "0",
                onKeydown: withKeys(($event) => toggleOverlay(timeInput.type), ["enter"]),
                onClick: ($event) => toggleOverlay(timeInput.type),
                ref_for: true,
                ref: (el) => assignRefs(el, i, 1)
              }, [
                _ctx.$slots[timeInput.type] ? renderSlot(_ctx.$slots, timeInput.type, {
                  key: 0,
                  text: unref(timeValueDisplay)(timeInput.type).text,
                  value: unref(timeValueDisplay)(timeInput.type).value
                }) : createCommentVNode("", true),
                !_ctx.$slots[timeInput.type] ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createTextVNode(toDisplayString(unref(timeValueDisplay)(timeInput.type).text), 1)
                ], 64)) : createCommentVNode("", true)
              ], 42, _hoisted_4$3),
              createElementVNode("div", {
                class: "dp__inc_dec_button",
                role: "button",
                "aria-label": unref(ariaLabels).decrementValue(timeInput.type),
                tabindex: "0",
                onKeydown: withKeys(($event) => handleTimeValue(timeInput.type, false), ["enter"]),
                onClick: ($event) => handleTimeValue(timeInput.type, false),
                ref_for: true,
                ref: (el) => assignRefs(el, i, 2)
              }, [
                _ctx.$slots["arrow-down"] ? renderSlot(_ctx.$slots, "arrow-down", { key: 0 }) : createCommentVNode("", true),
                !_ctx.$slots["arrow-down"] ? (openBlock(), createBlock(unref(ChevronDownIcon), { key: 1 })) : createCommentVNode("", true)
              ], 40, _hoisted_5$1)
            ], 64))
          ], 2);
        }), 128)),
        !_ctx.is24 ? (openBlock(), createElementBlock("div", _hoisted_6, [
          _ctx.$slots["am-pm-button"] ? renderSlot(_ctx.$slots, "am-pm-button", {
            key: 0,
            toggle: setAmPm,
            value: amPm.value
          }) : createCommentVNode("", true),
          !_ctx.$slots["am-pm-button"] ? (openBlock(), createElementBlock("button", {
            key: 1,
            ref_key: "amPmButton",
            ref: amPmButton,
            type: "button",
            class: "dp__pm_am_button",
            role: "button",
            "aria-label": unref(ariaLabels).amPmButton,
            tabindex: "0",
            onClick: setAmPm,
            onKeydown: withKeys(withModifiers(setAmPm, ["prevent"]), ["enter"])
          }, toDisplayString(amPm.value), 41, _hoisted_7)) : createCommentVNode("", true)
        ])) : createCommentVNode("", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(timeInputOverlays), (timeInput, i) => {
          return openBlock(), createBlock(Transition, {
            key: i,
            name: unref(transitionName)(overlays[timeInput.type]),
            css: unref(showTransition)
          }, {
            default: withCtx(() => [
              overlays[timeInput.type] ? (openBlock(), createBlock(_sfc_main$7, {
                key: 0,
                items: getGridItems(timeInput.type),
                "disabled-values": __props.filters.times[timeInput.type],
                "onUpdate:modelValue": ($event) => handleTimeFromOverlay(timeInput.type, $event),
                onSelected: ($event) => toggleOverlay(timeInput.type),
                onToggle: ($event) => toggleOverlay(timeInput.type),
                onResetFlow: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("reset-flow"))
              }, createSlots({
                "button-icon": withCtx(() => [
                  _ctx.$slots["clock-icon"] ? renderSlot(_ctx.$slots, "clock-icon", { key: 0 }) : createCommentVNode("", true),
                  !_ctx.$slots["clock-icon"] ? (openBlock(), createBlock(unref(ClockIcon), { key: 1 })) : createCommentVNode("", true)
                ]),
                _: 2
              }, [
                _ctx.$slots[`${timeInput.type}-overlay`] ? {
                  name: "item",
                  fn: withCtx(({ item }) => [
                    renderSlot(_ctx.$slots, `${timeInput.type}-overlay`, {
                      text: item.text,
                      value: item.value
                    })
                  ])
                } : void 0
              ]), 1032, ["items", "disabled-values", "onUpdate:modelValue", "onSelected", "onToggle"])) : createCommentVNode("", true)
            ]),
            _: 2
          }, 1032, ["name", "css"]);
        }), 128))
      ])) : createCommentVNode("", true);
    };
  }
});
const slots = [
  { name: "clock-icon", use: ["time", "calendar"] },
  { name: "arrow-left", use: ["month-year", "calendar"] },
  { name: "arrow-right", use: ["month-year", "calendar"] },
  { name: "arrow-up", use: ["time", "calendar"] },
  { name: "arrow-down", use: ["time", "calendar"] },
  { name: "calendar-icon", use: ["month-year", "time", "calendar"] },
  { name: "day", use: ["calendar"] },
  { name: "month-overlay", use: ["calendar", "month-year"] },
  { name: "year-overlay", use: ["calendar", "month-year"] },
  { name: "hours-overlay", use: ["calendar", "time"] },
  { name: "minutes-overlay", use: ["calendar", "time"] },
  { name: "seconds-overlay", use: ["calendar", "time"] },
  { name: "hours", use: ["calendar", "time"] },
  { name: "minutes", use: ["calendar", "time"] },
  { name: "month", use: ["calendar", "month-year"] },
  { name: "year", use: ["calendar", "month-year"] },
  { name: "action-select", use: ["action"] },
  { name: "action-preview", use: ["action"] },
  { name: "calendar-header", use: ["calendar"] },
  { name: "marker-tooltip", use: ["calendar"] },
  { name: "now-button", use: [] },
  { name: "time-picker-overlay", use: ["calendar", "time"] },
  { name: "am-pm-button", use: ["calendar", "time"] }
];
const inputSlots = [{ name: "trigger" }, { name: "input-icon" }, { name: "clear-icon" }, { name: "dp-input" }];
const slotNames = {
  all: () => slots,
  monthYear: () => slots.filter((slot) => slot.use.includes("month-year")),
  input: () => inputSlots,
  timePicker: () => slots.filter((slot) => slot.use.includes("time")),
  action: () => slots.filter((slot) => slot.use.includes("action")),
  calendar: () => slots.filter((slot) => slot.use.includes("calendar"))
};
const mapSlots = (slots2, usage) => {
  const toReturn = [];
  slotNames[usage]().forEach((slot) => {
    if (slots2[slot.name]) {
      toReturn.push(slot.name);
    }
  });
  return toReturn;
};
const _hoisted_1$4 = ["aria-label"];
const _hoisted_2$2 = { class: "dp__overlay_container dp__container_flex" };
const _hoisted_3$2 = {
  key: 1,
  class: "dp__overlay_row"
};
const _hoisted_4$2 = ["aria-label"];
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "TimePicker",
  props: {
    ...TimePickerProps,
    range: { type: Boolean, default: false },
    filters: { type: Object, default: () => ({}) },
    hours: { type: [Number, Array], default: 0 },
    minutes: { type: [Number, Array], default: 0 },
    seconds: { type: [Number, Array], default: 0 },
    customProps: { type: Object, default: null },
    modelAuto: { type: Boolean, default: false },
    internalModelValue: { type: [Date, Array], default: null }
  },
  emits: [
    "update:hours",
    "update:minutes",
    "update:seconds",
    "mount",
    "reset-flow",
    "overlay-closed"
  ],
  setup(__props, { expose, emit }) {
    const props = __props;
    const slots2 = useSlots();
    const openTimePickerBtn = ref(null);
    const closeTimePickerBtn = ref(null);
    const autoApply = inject(autoApplyKey, false);
    const timeInputRefs = ref([]);
    const overlayRef = ref(null);
    const ariaLabels = inject(ariaLabelsKey);
    const arrowNavigation = inject(arrowNavigationKey);
    const { transitionName, showTransition } = useTransitions();
    const { buildMatrix, setTimePicker } = useArrowNavigation();
    onMounted(() => {
      emit("mount");
      if (!props.timePicker && (arrowNavigation == null ? void 0 : arrowNavigation.value)) {
        buildMatrix([unrefElement(openTimePickerBtn.value)], "time");
      } else {
        setTimePicker(true, props.timePicker);
      }
    });
    const shouldShowRangedInput = computed(() => {
      if (props.range && props.modelAuto)
        return isModelAuto(props.internalModelValue);
      return true;
    });
    const showTimePicker = ref(false);
    const getTimeInput = (i) => {
      return {
        hours: Array.isArray(props.hours) ? props.hours[i] : props.hours,
        minutes: Array.isArray(props.minutes) ? props.minutes[i] : props.minutes,
        seconds: Array.isArray(props.seconds) ? props.seconds[i] : props.seconds
      };
    };
    const timeInputs = computed(() => {
      const arr = [];
      if (props.range) {
        for (let i = 0; i < 2; i++) {
          arr.push(getTimeInput(i));
        }
      } else {
        arr.push(getTimeInput(0));
      }
      return arr;
    });
    const toggleTimePicker = (show, flow = false, childOpen = "") => {
      if (!flow) {
        emit("reset-flow");
      }
      showTimePicker.value = show;
      if (arrowNavigation == null ? void 0 : arrowNavigation.value) {
        setTimePicker(show);
        if (!show) {
          emit("overlay-closed");
        }
      }
      nextTick(() => {
        if (childOpen !== "" && timeInputRefs.value[0]) {
          timeInputRefs.value[0].openChildCmp(childOpen);
        }
      });
    };
    const toggleButtonClass = computed(() => ({
      dp__button: true,
      dp__button_bottom: autoApply
    }));
    const timeInputSlots = mapSlots(slots2, "timePicker");
    const getEvent = (event, index, property) => {
      if (!props.range) {
        return event;
      }
      if (index === 0) {
        return [event, timeInputs.value[1][property]];
      }
      return [timeInputs.value[0][property], event];
    };
    const updateHours = (hours) => {
      emit("update:hours", hours);
    };
    const updateMinutes = (minutes) => {
      emit("update:minutes", minutes);
    };
    const updateSeconds = (seconds) => {
      emit("update:seconds", seconds);
    };
    const focusOverlay = () => {
      if (overlayRef.value && (arrowNavigation == null ? void 0 : arrowNavigation.value)) {
        overlayRef.value.focus({ preventScroll: true });
      }
    };
    expose({ toggleTimePicker });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        !_ctx.timePicker ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(unref(toggleButtonClass)),
          role: "button",
          "aria-label": unref(ariaLabels).openTimePicker,
          tabindex: "0",
          ref_key: "openTimePickerBtn",
          ref: openTimePickerBtn,
          onKeydown: _cache[0] || (_cache[0] = withKeys(($event) => toggleTimePicker(true), ["enter"])),
          onClick: _cache[1] || (_cache[1] = ($event) => toggleTimePicker(true))
        }, [
          _ctx.$slots["clock-icon"] ? renderSlot(_ctx.$slots, "clock-icon", { key: 0 }) : createCommentVNode("", true),
          !_ctx.$slots["clock-icon"] ? (openBlock(), createBlock(unref(ClockIcon), { key: 1 })) : createCommentVNode("", true)
        ], 42, _hoisted_1$4)) : createCommentVNode("", true),
        createVNode(Transition, {
          name: unref(transitionName)(showTimePicker.value),
          css: unref(showTransition)
        }, {
          default: withCtx(() => [
            showTimePicker.value || _ctx.timePicker ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "dp__overlay",
              ref_key: "overlayRef",
              ref: overlayRef,
              tabindex: "0"
            }, [
              createElementVNode("div", _hoisted_2$2, [
                _ctx.$slots["time-picker-overlay"] ? renderSlot(_ctx.$slots, "time-picker-overlay", {
                  key: 0,
                  range: __props.range,
                  hours: __props.hours,
                  minutes: __props.minutes,
                  seconds: __props.seconds,
                  setHours: updateHours,
                  setMinutes: updateMinutes,
                  setSeconds: updateSeconds
                }) : createCommentVNode("", true),
                !_ctx.$slots["time-picker-overlay"] ? (openBlock(), createElementBlock("div", _hoisted_3$2, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(timeInputs), (tInput, index) => {
                    return withDirectives((openBlock(), createBlock(_sfc_main$6, mergeProps({
                      key: index,
                      disabled: index === 0 ? _ctx.fixedStart : _ctx.fixedEnd,
                      hours: tInput.hours,
                      minutes: tInput.minutes,
                      seconds: tInput.seconds,
                      filters: __props.filters,
                      ref_for: true,
                      ref_key: "timeInputRefs",
                      ref: timeInputRefs
                    }, {
                      is24: _ctx.is24,
                      hoursGridIncrement: _ctx.hoursGridIncrement,
                      minutesGridIncrement: _ctx.minutesGridIncrement,
                      secondsGridIncrement: _ctx.secondsGridIncrement,
                      hoursIncrement: _ctx.hoursIncrement,
                      minutesIncrement: _ctx.minutesIncrement,
                      secondsIncrement: _ctx.secondsIncrement,
                      filters: __props.filters,
                      noHoursOverlay: _ctx.noHoursOverlay,
                      noMinutesOverlay: _ctx.noMinutesOverlay,
                      noSecondsOverlay: _ctx.noSecondsOverlay,
                      enableSeconds: _ctx.enableSeconds,
                      closeTimePickerBtn: closeTimePickerBtn.value,
                      order: index
                    }, {
                      "onUpdate:hours": ($event) => updateHours(getEvent($event, index, "hours")),
                      "onUpdate:minutes": ($event) => updateMinutes(getEvent($event, index, "minutes")),
                      "onUpdate:seconds": ($event) => updateSeconds(getEvent($event, index, "seconds")),
                      onMounted: focusOverlay,
                      onOverlayClosed: focusOverlay
                    }), createSlots({ _: 2 }, [
                      renderList(unref(timeInputSlots), (slot, i) => {
                        return {
                          name: slot,
                          fn: withCtx((args) => [
                            renderSlot(_ctx.$slots, slot, normalizeProps(guardReactiveProps(args)))
                          ])
                        };
                      })
                    ]), 1040, ["disabled", "hours", "minutes", "seconds", "filters", "onUpdate:hours", "onUpdate:minutes", "onUpdate:seconds"])), [
                      [vShow, index === 0 ? true : unref(shouldShowRangedInput)]
                    ]);
                  }), 128))
                ])) : createCommentVNode("", true),
                !_ctx.timePicker ? (openBlock(), createElementBlock("div", {
                  key: 2,
                  ref_key: "closeTimePickerBtn",
                  ref: closeTimePickerBtn,
                  class: normalizeClass(unref(toggleButtonClass)),
                  role: "button",
                  "aria-label": unref(ariaLabels).closeTimePicker,
                  tabindex: "0",
                  onKeydown: _cache[2] || (_cache[2] = withKeys(($event) => toggleTimePicker(false), ["enter"])),
                  onClick: _cache[3] || (_cache[3] = ($event) => toggleTimePicker(false))
                }, [
                  _ctx.$slots["calendar-icon"] ? renderSlot(_ctx.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true),
                  !_ctx.$slots["calendar-icon"] ? (openBlock(), createBlock(unref(CalendarIcon), { key: 1 })) : createCommentVNode("", true)
                ], 42, _hoisted_4$2)) : createCommentVNode("", true)
              ])
            ], 512)) : createCommentVNode("", true)
          ]),
          _: 3
        }, 8, ["name", "css"])
      ]);
    };
  }
});
const _hoisted_1$3 = ["aria-label"];
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "ActionIcon",
  props: { ariaLabel: { type: String, default: "" } },
  emits: ["activate", "setRef"],
  setup(__props, { emit }) {
    const elRef = ref(null);
    onMounted(() => emit("setRef", elRef));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "dp__month_year_col_nav",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("activate")),
        onKeydown: _cache[1] || (_cache[1] = withKeys(($event) => _ctx.$emit("activate"), ["enter"])),
        tabindex: "0",
        ref_key: "elRef",
        ref: elRef
      }, [
        createElementVNode("div", {
          class: "dp__inner_nav",
          role: "button",
          "aria-label": __props.ariaLabel
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 8, _hoisted_1$3)
      ], 544);
    };
  }
});
const _hoisted_1$2 = ["aria-label"];
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "RegularPicker",
  props: {
    ariaLabel: { type: String, default: "" },
    showSelectionGrid: { type: Boolean, default: false },
    modelValue: { type: Number, default: null },
    items: { type: Array, default: () => [] },
    disabledValues: { type: Array, default: () => [] },
    minValue: { type: Number, default: null },
    maxValue: { type: Number, default: null },
    slotName: { type: String, default: "" },
    headerRefs: { type: Array, default: () => [] }
  },
  emits: ["update:model-value", "toggle", "setRef"],
  setup(__props, { emit }) {
    const { transitionName, showTransition } = useTransitions();
    const elRef = ref(null);
    onMounted(() => emit("setRef", elRef));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createElementVNode("div", {
          class: "dp__month_year_select",
          onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("toggle")),
          onKeydown: _cache[1] || (_cache[1] = withKeys(($event) => _ctx.$emit("toggle"), ["enter"])),
          role: "button",
          "aria-label": __props.ariaLabel,
          tabindex: "0",
          ref_key: "elRef",
          ref: elRef
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 40, _hoisted_1$2),
        createVNode(Transition, {
          name: unref(transitionName)(__props.showSelectionGrid),
          css: unref(showTransition)
        }, {
          default: withCtx(() => [
            __props.showSelectionGrid ? (openBlock(), createBlock(_sfc_main$7, mergeProps({ key: 0 }, {
              modelValue: __props.modelValue,
              items: __props.items,
              disabledValues: __props.disabledValues,
              minValue: __props.minValue,
              maxValue: __props.maxValue
            }, {
              "header-refs": [],
              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.$emit("update:model-value", $event)),
              onToggle: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("toggle"))
            }), createSlots({
              "button-icon": withCtx(() => [
                _ctx.$slots["calendar-icon"] ? renderSlot(_ctx.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true),
                !_ctx.$slots["calendar-icon"] ? (openBlock(), createBlock(unref(CalendarIcon), { key: 1 })) : createCommentVNode("", true)
              ]),
              _: 2
            }, [
              _ctx.$slots[__props.slotName] ? {
                name: "item",
                fn: withCtx(({ item }) => [
                  renderSlot(_ctx.$slots, __props.slotName, { item })
                ])
              } : void 0
            ]), 1040)) : createCommentVNode("", true)
          ]),
          _: 3
        }, 8, ["name", "css"])
      ], 64);
    };
  }
});
const getDateForCompare = (date, month, year) => {
  return [set(new Date(date), { date: 1 }), set(new Date(), { month, year, date: 1 })];
};
const validateMinDate = (minDate, month, year) => {
  return isDateBefore(...getDateForCompare(minDate, month, year)) || isDateEqual(...getDateForCompare(minDate, month, year));
};
const validateMaxDate = (maxDate, month, year) => {
  return isDateAfter(...getDateForCompare(maxDate, month, year)) || isDateEqual(...getDateForCompare(maxDate, month, year));
};
const validateMonthYearInRange = (minDate, maxDate, month, year, isNext, preventNav) => {
  let valid = false;
  if (preventNav) {
    if (minDate && maxDate) {
      if (maxDate && isNext && validateMaxDate(maxDate, month, year)) {
        valid = true;
      }
      if (minDate && !isNext && validateMinDate(minDate, month, year)) {
        valid = true;
      }
    } else if (minDate && validateMinDate(minDate, month, year)) {
      valid = true;
    } else if (maxDate && validateMaxDate(maxDate, month, year)) {
      valid = true;
    }
  } else {
    valid = true;
  }
  return valid;
};
const useMontYearPick = (props, emit) => {
  const recursiveMonthAdjust = (date, increment) => {
    let monthDate = date;
    if (props.filters.months.includes(getMonth(monthDate))) {
      monthDate = increment ? addMonths(date, 1) : subMonths(date, 1);
      return recursiveMonthAdjust(monthDate, increment);
    }
    return monthDate;
  };
  const recursiveYearAdjust = (date, increment) => {
    let yearDate = date;
    if (props.filters.years.includes(getYear(yearDate))) {
      yearDate = increment ? addYears(date, 1) : subYears(date, 1);
      return recursiveYearAdjust(yearDate, increment);
    }
    return yearDate;
  };
  const handleMonthYearChange = (isNext) => {
    const initialDate = set(new Date(), { month: props.month, year: props.year });
    let date = isNext ? addMonths(initialDate, 1) : subMonths(initialDate, 1);
    let month = getMonth(date);
    let year = getYear(date);
    if (props.filters.months.includes(month)) {
      date = recursiveMonthAdjust(date, isNext);
      month = getMonth(date);
      year = getYear(date);
    }
    if (props.filters.years.includes(year)) {
      date = recursiveYearAdjust(date, isNext);
      year = getYear(date);
    }
    if (validateMonthYearInRange(props.minDate, props.maxDate, month, year, isNext, props.preventMinMaxNavigation)) {
      updateMonthYear(month, year);
    }
  };
  const updateMonthYear = (month, year) => {
    emit("update-month-year", { month, year });
  };
  return { handleMonthYearChange };
};
const _hoisted_1$1 = { class: "dp__month_year_row" };
const _hoisted_2$1 = { class: "dp__month_picker_header" };
const _hoisted_3$1 = ["aria-label"];
const _hoisted_4$1 = ["aria-label", "onKeydown"];
const _hoisted_5 = ["aria-label"];
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "MonthYearPicker",
  props: {
    ...MonthCalendarSharedProps,
    ...DateValidationProps,
    preventMinMaxNavigation: { type: Boolean, default: false },
    reverseYears: { type: Boolean, default: false },
    years: { type: Array, default: () => [] },
    months: { type: Array, default: () => [] },
    filters: { type: Object, default: () => ({}) },
    multiCalendarsSolo: { type: Boolean, default: false },
    yearPicker: { type: Boolean, default: false }
  },
  emits: ["update-month-year", "monthYearSelect", "mount", "reset-flow", "overlay-closed"],
  setup(__props, { expose, emit }) {
    const props = __props;
    const { transitionName, showTransition } = useTransitions();
    const { buildMatrix } = useArrowNavigation();
    const showMonthPicker = ref(false);
    const showYearPicker = ref(false);
    const elementRefs = ref([null, null, null, null]);
    const mpPrevIconRef = ref(null);
    const mpYearButtonRef = ref(null);
    const mpNextIconRef = ref(null);
    const ariaLabels = inject(ariaLabelsKey);
    const arrowNavigation = inject(arrowNavigationKey);
    const { handleMonthYearChange } = useMontYearPick(props, emit);
    onMounted(() => {
      emit("mount");
    });
    const bindOptions = (type) => ({
      get: () => props[type],
      set: (value) => {
        const otherType = type === "month" ? "year" : "month";
        emit("update-month-year", { [type]: value, [otherType]: props[otherType] });
        emit("monthYearSelect", type === "year");
        if (type === "month") {
          toggleMonthPicker(true);
        } else {
          toggleYearPicker(true);
        }
      }
    });
    const monthModelBind = computed(bindOptions("month"));
    const yearModelBind = computed(bindOptions("year"));
    const childProps = computed(() => (type) => {
      const isMonth2 = type === "month";
      return {
        showSelectionGrid: (isMonth2 ? showMonthPicker : showYearPicker).value,
        items: (isMonth2 ? groupedMonths : groupedYears).value,
        disabledValues: props.filters[isMonth2 ? "months" : "years"],
        minValue: (isMonth2 ? minMonth : minYear).value,
        maxValue: (isMonth2 ? maxMonth : maxYear).value,
        headerRefs: isMonth2 && props.monthPicker ? [mpPrevIconRef.value, mpYearButtonRef.value, mpNextIconRef.value] : []
      };
    });
    const minYear = computed(() => props.minDate ? getYear(new Date(props.minDate)) : null);
    const maxYear = computed(() => props.maxDate ? getYear(new Date(props.maxDate)) : null);
    const minMonth = computed(() => {
      if (props.minDate && minYear.value) {
        if (minYear.value > props.year)
          return 12;
        if (minYear.value === props.year)
          return getMonth(new Date(props.minDate));
      }
      return null;
    });
    const maxMonth = computed(() => {
      if (props.maxDate && maxYear.value) {
        if (maxYear.value < props.year)
          return -1;
        if (maxYear.value === props.year)
          return getMonth(new Date(props.maxDate));
        return null;
      }
      return null;
    });
    const multiModelValue = computed(() => {
      return props.range && props.internalModelValue && (props.monthPicker || props.yearPicker) ? props.internalModelValue : [];
    });
    const getGroupedList = (items, reverse = false) => {
      const list = [];
      for (let i = 0; i < items.length; i += 3) {
        const listItems = [items[i], items[i + 1], items[i + 2]];
        list.push(reverse ? listItems.reverse() : listItems);
      }
      return reverse ? list.reverse() : list;
    };
    const getMonthDisplayVal = computed(() => {
      const month = props.months.find((month2) => month2.value === props.month);
      if (month)
        return month;
      return { text: "", value: 0 };
    });
    const groupedMonths = computed(() => {
      return getGroupedList(props.months);
    });
    const groupedYears = computed(() => {
      return getGroupedList(props.years, props.reverseYears);
    });
    const showLeftIcon = computed(() => {
      if (props.multiCalendars) {
        return !props.multiCalendarsSolo ? props.instance === 0 : true;
      }
      return true;
    });
    const showRightIcon = computed(() => {
      if (props.multiCalendars) {
        return !props.multiCalendarsSolo ? props.instance === props.multiCalendars - 1 : true;
      }
      return true;
    });
    const toggleMonthPicker = (flow = false) => {
      checkFlow(flow);
      showMonthPicker.value = !showMonthPicker.value;
      if (!showMonthPicker.value) {
        emit("overlay-closed");
      }
    };
    const toggleYearPicker = (flow = false) => {
      checkFlow(flow);
      showYearPicker.value = !showYearPicker.value;
      if (!showYearPicker.value) {
        emit("overlay-closed");
      }
    };
    const checkFlow = (flow) => {
      if (!flow) {
        emit("reset-flow");
      }
    };
    const handleYear = (increment = false) => {
      emit("update-month-year", { year: increment ? props.year + 1 : props.year - 1, month: props.month });
    };
    const setElRefs = (el, i) => {
      if (arrowNavigation == null ? void 0 : arrowNavigation.value) {
        elementRefs.value[i] = unrefElement(el);
        buildMatrix(elementRefs.value, "monthYear");
      }
    };
    expose({
      toggleMonthPicker,
      toggleYearPicker
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1, [
        !_ctx.monthPicker && !__props.yearPicker ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          unref(showLeftIcon) && !_ctx.vertical ? (openBlock(), createBlock(_sfc_main$4, {
            key: 0,
            "aria-label": unref(ariaLabels).prevMonth,
            onActivate: _cache[0] || (_cache[0] = ($event) => unref(handleMonthYearChange)(false)),
            onSetRef: _cache[1] || (_cache[1] = ($event) => setElRefs($event, 0))
          }, {
            default: withCtx(() => [
              _ctx.$slots["arrow-left"] ? renderSlot(_ctx.$slots, "arrow-left", { key: 0 }) : createCommentVNode("", true),
              !_ctx.$slots["arrow-left"] ? (openBlock(), createBlock(unref(ChevronLeftIcon), { key: 1 })) : createCommentVNode("", true)
            ]),
            _: 3
          }, 8, ["aria-label"])) : createCommentVNode("", true),
          createVNode(_sfc_main$3, mergeProps({
            "aria-label": unref(ariaLabels).openMonthsOverlay,
            "slot-name": "month-overlay",
            modelValue: unref(monthModelBind),
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => isRef(monthModelBind) ? monthModelBind.value = $event : null)
          }, unref(childProps)("month"), {
            onToggle: toggleMonthPicker,
            onSetRef: _cache[3] || (_cache[3] = ($event) => setElRefs($event, 1))
          }), createSlots({
            default: withCtx(() => [
              _ctx.$slots.month ? renderSlot(_ctx.$slots, "month", normalizeProps(mergeProps({ key: 0 }, unref(getMonthDisplayVal)))) : createCommentVNode("", true),
              !_ctx.$slots.month ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createTextVNode(toDisplayString(unref(getMonthDisplayVal).text), 1)
              ], 64)) : createCommentVNode("", true)
            ]),
            _: 2
          }, [
            _ctx.$slots["calendar-icon"] ? {
              name: "calendar-icon",
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, "calendar-icon")
              ])
            } : void 0,
            _ctx.$slots["month-overlay"] ? {
              name: "month-overlay",
              fn: withCtx(({ item }) => [
                renderSlot(_ctx.$slots, "month-overlay", {
                  text: item.text,
                  value: item.value
                })
              ])
            } : void 0
          ]), 1040, ["aria-label", "modelValue"]),
          createVNode(_sfc_main$3, mergeProps({
            "aria-label": unref(ariaLabels).openYearsOverlay,
            "slot-name": "year-overlay",
            modelValue: unref(yearModelBind),
            "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => isRef(yearModelBind) ? yearModelBind.value = $event : null)
          }, unref(childProps)("year"), {
            onToggle: toggleYearPicker,
            onSetRef: _cache[5] || (_cache[5] = ($event) => setElRefs($event, 2))
          }), createSlots({
            default: withCtx(() => [
              _ctx.$slots.year ? renderSlot(_ctx.$slots, "year", {
                key: 0,
                year: _ctx.year
              }) : createCommentVNode("", true),
              !_ctx.$slots.year ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createTextVNode(toDisplayString(_ctx.year), 1)
              ], 64)) : createCommentVNode("", true)
            ]),
            _: 2
          }, [
            _ctx.$slots["calendar-icon"] ? {
              name: "calendar-icon",
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, "calendar-icon")
              ])
            } : void 0,
            _ctx.$slots["year-overlay"] ? {
              name: "year-overlay",
              fn: withCtx(({ item }) => [
                renderSlot(_ctx.$slots, "year-overlay", {
                  text: item.text,
                  value: item.value
                })
              ])
            } : void 0
          ]), 1040, ["aria-label", "modelValue"]),
          unref(showLeftIcon) && _ctx.vertical ? (openBlock(), createBlock(_sfc_main$4, {
            key: 1,
            "aria-label": unref(ariaLabels).prevMonth,
            onActivate: _cache[6] || (_cache[6] = ($event) => unref(handleMonthYearChange)(false))
          }, {
            default: withCtx(() => [
              _ctx.$slots["arrow-up"] ? renderSlot(_ctx.$slots, "arrow-up", { key: 0 }) : createCommentVNode("", true),
              !_ctx.$slots["arrow-up"] ? (openBlock(), createBlock(unref(ChevronUpIcon), { key: 1 })) : createCommentVNode("", true)
            ]),
            _: 3
          }, 8, ["aria-label"])) : createCommentVNode("", true),
          unref(showRightIcon) ? (openBlock(), createBlock(_sfc_main$4, {
            key: 2,
            "arial-label": unref(ariaLabels).nextMonth,
            onActivate: _cache[7] || (_cache[7] = ($event) => unref(handleMonthYearChange)(true)),
            ref: "rightIcon",
            onSetRef: _cache[8] || (_cache[8] = ($event) => setElRefs($event, 3))
          }, {
            default: withCtx(() => [
              _ctx.$slots[_ctx.vertical ? "arrow-down" : "arrow-right"] ? renderSlot(_ctx.$slots, _ctx.vertical ? "arrow-down" : "arrow-right", { key: 0 }) : createCommentVNode("", true),
              !_ctx.$slots[_ctx.vertical ? "arrow-down" : "arrow-right"] ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.vertical ? unref(ChevronDownIcon) : unref(ChevronRightIcon)), { key: 1 })) : createCommentVNode("", true)
            ]),
            _: 3
          }, 8, ["arial-label"])) : createCommentVNode("", true)
        ], 64)) : createCommentVNode("", true),
        _ctx.monthPicker ? (openBlock(), createBlock(_sfc_main$7, mergeProps({ key: 1 }, unref(childProps)("month"), {
          "skip-active": props.range,
          year: _ctx.year,
          "multi-model-value": unref(multiModelValue),
          "month-picker": "",
          modelValue: unref(monthModelBind),
          "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => isRef(monthModelBind) ? monthModelBind.value = $event : null),
          onToggle: toggleMonthPicker,
          onSelected: _cache[16] || (_cache[16] = ($event) => _ctx.$emit("overlay-closed"))
        }), createSlots({
          header: withCtx(() => [
            createElementVNode("div", _hoisted_2$1, [
              createElementVNode("div", {
                class: "dp__month_year_col_nav",
                tabindex: "0",
                ref_key: "mpPrevIconRef",
                ref: mpPrevIconRef,
                onClick: _cache[9] || (_cache[9] = ($event) => handleYear(false)),
                onKeydown: _cache[10] || (_cache[10] = withKeys(($event) => handleYear(false), ["enter"]))
              }, [
                createElementVNode("div", {
                  class: "dp__inner_nav",
                  role: "button",
                  "aria-label": unref(ariaLabels).prevMonth
                }, [
                  _ctx.$slots["arrow-left"] ? renderSlot(_ctx.$slots, "arrow-left", { key: 0 }) : createCommentVNode("", true),
                  !_ctx.$slots["arrow-left"] ? (openBlock(), createBlock(unref(ChevronLeftIcon), { key: 1 })) : createCommentVNode("", true)
                ], 8, _hoisted_3$1)
              ], 544),
              createElementVNode("div", {
                class: "dp__pointer",
                role: "button",
                ref_key: "mpYearButtonRef",
                ref: mpYearButtonRef,
                "aria-label": unref(ariaLabels).openYearsOverlay,
                tabindex: "0",
                onClick: toggleYearPicker,
                onKeydown: withKeys(toggleYearPicker, ["enter"])
              }, [
                _ctx.$slots.year ? renderSlot(_ctx.$slots, "year", {
                  key: 0,
                  year: _ctx.year
                }) : createCommentVNode("", true),
                !_ctx.$slots.year ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createTextVNode(toDisplayString(_ctx.year), 1)
                ], 64)) : createCommentVNode("", true)
              ], 40, _hoisted_4$1),
              createElementVNode("div", {
                class: "dp__month_year_col_nav",
                tabindex: "0",
                ref_key: "mpNextIconRef",
                ref: mpNextIconRef,
                onClick: _cache[11] || (_cache[11] = ($event) => handleYear(true)),
                onKeydown: _cache[12] || (_cache[12] = withKeys(($event) => handleYear(true), ["enter"]))
              }, [
                createElementVNode("div", {
                  class: "dp__inner_nav",
                  role: "button",
                  "aria-label": unref(ariaLabels).nextMonth
                }, [
                  _ctx.$slots["arrow-right"] ? renderSlot(_ctx.$slots, "arrow-right", { key: 0 }) : createCommentVNode("", true),
                  !_ctx.$slots["arrow-right"] ? (openBlock(), createBlock(unref(ChevronRightIcon), { key: 1 })) : createCommentVNode("", true)
                ], 8, _hoisted_5)
              ], 544)
            ]),
            createVNode(Transition, {
              name: unref(transitionName)(showYearPicker.value),
              css: unref(showTransition)
            }, {
              default: withCtx(() => [
                showYearPicker.value ? (openBlock(), createBlock(_sfc_main$7, mergeProps({ key: 0 }, unref(childProps)("year"), {
                  modelValue: unref(yearModelBind),
                  "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => isRef(yearModelBind) ? yearModelBind.value = $event : null),
                  onToggle: toggleYearPicker,
                  onSelected: _cache[14] || (_cache[14] = ($event) => _ctx.$emit("overlay-closed"))
                }), createSlots({
                  "button-icon": withCtx(() => [
                    _ctx.$slots["calendar-icon"] ? renderSlot(_ctx.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true),
                    !_ctx.$slots["calendar-icon"] ? (openBlock(), createBlock(unref(CalendarIcon), { key: 1 })) : createCommentVNode("", true)
                  ]),
                  _: 2
                }, [
                  _ctx.$slots["year-overlay"] ? {
                    name: "item",
                    fn: withCtx(({ item }) => [
                      renderSlot(_ctx.$slots, "year-overlay", {
                        text: item.text,
                        value: item.value
                      })
                    ])
                  } : void 0
                ]), 1040, ["modelValue"])) : createCommentVNode("", true)
              ]),
              _: 3
            }, 8, ["name", "css"])
          ]),
          _: 2
        }, [
          _ctx.$slots["month-overlay"] ? {
            name: "item",
            fn: withCtx(({ item }) => [
              renderSlot(_ctx.$slots, "month-overlay", {
                text: item.text,
                value: item.value
              })
            ])
          } : void 0
        ]), 1040, ["skip-active", "year", "multi-model-value", "modelValue"])) : createCommentVNode("", true),
        __props.yearPicker ? (openBlock(), createBlock(_sfc_main$7, mergeProps({ key: 2 }, unref(childProps)("year"), {
          modelValue: unref(yearModelBind),
          "onUpdate:modelValue": _cache[17] || (_cache[17] = ($event) => isRef(yearModelBind) ? yearModelBind.value = $event : null),
          "multi-model-value": unref(multiModelValue),
          "skip-active": props.range,
          "skip-button-ref": "",
          "year-picker": "",
          onToggle: toggleYearPicker,
          onSelected: _cache[18] || (_cache[18] = ($event) => _ctx.$emit("overlay-closed"))
        }), createSlots({ _: 2 }, [
          _ctx.$slots["year-overlay"] ? {
            name: "item",
            fn: withCtx(({ item }) => [
              renderSlot(_ctx.$slots, "year-overlay", {
                text: item.text,
                value: item.value
              })
            ])
          } : void 0
        ]), 1040, ["modelValue", "multi-model-value", "skip-active"])) : createCommentVNode("", true)
      ]);
    };
  }
});
const useCalendar = (props, emit, updateFlow, calendarRefs) => {
  const today = ref(new Date());
  const hoveredDate = ref();
  const calendars = ref([{ month: getMonth(new Date()), year: getYear(new Date()) }]);
  const hours = ref(props.range ? [getHours(new Date()), getHours(new Date())] : getHours(new Date()));
  const minutes = ref(props.range ? [getMinutes(new Date()), getMinutes(new Date())] : getMinutes(new Date()));
  const seconds = ref(props.range ? [0, 0] : 0);
  watch(calendars, () => {
    setTimeout(() => {
      if (props.openOnTop) {
        emit("dpOpen");
      }
    }, 0);
  }, { deep: true });
  onMounted(() => {
    mapInternalModuleValues(true);
    if (!modelValue.value) {
      if (props.startDate) {
        calendars.value[0].month = getMonth(new Date(props.startDate));
        calendars.value[0].year = getYear(new Date(props.startDate));
        if (props.multiCalendars) {
          autoChangeMultiCalendars(0);
        }
      }
      if (props.startTime) {
        assignStartTime();
      }
    }
  });
  const month = computed(() => (instance) => calendars.value[instance] ? calendars.value[instance].month : 0);
  const year = computed(() => (instance) => calendars.value[instance] ? calendars.value[instance].year : 0);
  const setCalendarMonthYear = (instance, month2, year2) => {
    calendars.value[instance].month = month2;
    calendars.value[instance].year = year2;
  };
  const setCalendarMonth = (instance, value) => calendars.value[instance].month = value;
  const setCalendarYear = (instance, value) => calendars.value[instance].year = value;
  const getSecondsValue = (getFirst = true) => {
    if (props.enableSeconds) {
      if (Array.isArray(seconds.value)) {
        return getFirst ? seconds.value[0] : seconds.value[1];
      }
      return seconds.value;
    }
    return 0;
  };
  const assignStartTime = () => {
    if (props.startTime) {
      if (isTimeArr(props.startTime)) {
        hours.value = [+props.startTime[0].hours, +props.startTime[1].hours];
        minutes.value = [+props.startTime[0].minutes, +props.startTime[1].minutes];
        if (props.enableSeconds) {
          seconds.value = [+props.startTime[0].seconds, +props.startTime[1].seconds];
        }
      } else {
        hours.value = +props.startTime.hours;
        minutes.value = +props.startTime.minutes;
        if (props.enableSeconds) {
          seconds.value = +props.startTime.seconds;
        }
      }
    }
  };
  const modelValue = computed({
    get: () => {
      return props.internalModelValue;
    },
    set: (value) => {
      if (!props.readonly && !props.disabled) {
        emit("update:internalModelValue", value);
      }
    }
  });
  watch(modelValue, () => mapInternalModuleValues());
  const isDisabled = (date) => {
    const { validate } = dateValidator(props.minDate, props.maxDate, props.disabledDates, props.allowedDates, props.filters, props.disabledWeekDays, props.yearRange);
    return !validate(date);
  };
  const isActiveDate = (calendarDay) => {
    if (!modelValue.value)
      return false;
    if (props.hideOffsetDates && !calendarDay.current)
      return false;
    if (!props.range) {
      if (props.multiDates && Array.isArray(modelValue.value)) {
        return modelValue.value.some((dateVal) => isDateEqual(dateVal, calendarDay.value));
      }
      return isDateEqual(calendarDay.value, modelValue.value ? modelValue.value : today.value);
    }
    if (props.modelAuto && Array.isArray(modelValue.value)) {
      return isDateEqual(calendarDay.value, modelValue.value[0] ? modelValue.value[0] : today.value);
    }
    return false;
  };
  const rangeActive = (calendarDay) => {
    return isDateBetween(modelValue.value, hoveredDate.value, calendarDay.value);
  };
  const assignMonthAndYear = (date, fromMount = false) => {
    if (!props.multiCalendars || !props.multiStatic || fromMount) {
      setCalendarMonth(0, getMonth(date));
      setCalendarYear(0, getYear(date));
    }
    if (props.multiCalendars) {
      for (let i = 1; i <= props.multiCalendars; i++) {
        const prevDate = set(new Date(), { month: month.value(i - 1), year: year.value(i - 1) });
        const nextMonth = add(prevDate, { months: 1 });
        calendars.value[i] = { month: getMonth(nextMonth), year: getYear(nextMonth) };
      }
    }
  };
  const handleNextMonthYear = () => {
    if (Array.isArray(modelValue.value) && modelValue.value.length === 2) {
      const date = new Date(modelValue.value[1] ? modelValue.value[1] : addMonths(modelValue.value[0], 1));
      const [firstMonth, firstYear] = [getMonth(modelValue.value[0]), getYear(modelValue.value[0])];
      const [secondMonth, secondYear] = [getMonth(modelValue.value[1]), getYear(modelValue.value[1])];
      if ((firstMonth !== secondMonth || firstMonth === secondMonth && firstYear !== secondYear) && props.multiCalendarsSolo) {
        setCalendarMonth(1, getMonth(date));
        setCalendarYear(1, getYear(date));
      }
    }
  };
  const assignMonthYearAndTime = (date) => {
    assignMonthAndYear(date);
    hours.value = getHours(date);
    minutes.value = getMinutes(date);
    seconds.value = getSeconds(date);
  };
  const multiDatesLast = () => {
    if (Array.isArray(modelValue.value) && modelValue.value.length) {
      return modelValue.value[modelValue.value.length - 1];
    }
    return null;
  };
  const mapInternalModuleValues = (fromMount = false) => {
    if (modelValue.value) {
      if (isModelValueRange(modelValue.value)) {
        if (modelValue.value.length === 2 && !props.multiDates) {
          assignMonthAndYear(modelValue.value[0], fromMount);
          hours.value = [
            getHours(modelValue.value[0]),
            modelValue.value[1] ? getHours(modelValue.value[1]) : getHours(new Date())
          ];
          minutes.value = [
            getMinutes(modelValue.value[0]),
            modelValue.value[1] ? getMinutes(modelValue.value[1]) : getMinutes(new Date())
          ];
          seconds.value = [
            getSeconds(modelValue.value[0]),
            modelValue.value[1] ? getSeconds(modelValue.value[1]) : getSeconds(new Date())
          ];
        } else if (isModelValueRange(modelValue.value) && props.multiDates) {
          const lastEntry = modelValue.value[modelValue.value.length - 1];
          if (lastEntry) {
            assignMonthYearAndTime(lastEntry);
          }
        }
        if (props.multiCalendars && props.multiCalendarsSolo) {
          handleNextMonthYear();
        }
      } else {
        assignMonthYearAndTime(modelValue.value);
      }
    } else {
      if (props.timePicker) {
        assignStartTime();
        if (!props.range) {
          modelValue.value = setDateTime(new Date(), hours.value, minutes.value, getSecondsValue());
        } else if (isNumberArray(hours.value) && isNumberArray(minutes.value)) {
          modelValue.value = [
            setDateTime(new Date(), hours.value[0], minutes.value[0], getSecondsValue()),
            setDateTime(new Date(), hours.value[1], minutes.value[1], getSecondsValue(false))
          ];
        }
      } else if (props.monthPicker && !props.range) {
        modelValue.value = setDateMonthOrYear(new Date(), month.value(0), year.value(0));
      } else if (props.multiCalendars) {
        assignMonthAndYear(new Date());
      } else if (props.yearPicker && !props.range) {
        modelValue.value = new Date();
      }
    }
  };
  const handleNextCalendarAutoRange = (date) => {
    const monthValue = getMonth(new Date(date));
    const yearValue = getYear(new Date(date));
    setCalendarMonth(0, monthValue);
    setCalendarYear(0, yearValue);
    if (props.multiCalendars > 0) {
      for (let i = 1; i < props.multiCalendars; i++) {
        const next = getNextMonthYear(set(new Date(date), { year: month.value(i - 1), month: year.value(i - 1) }));
        setCalendarMonth(i, next.month);
        setCalendarYear(i, next.year);
      }
    }
  };
  const handleMultiDateSelect = (date) => {
    if (modelValue.value && Array.isArray(modelValue.value)) {
      if (modelValue.value.some((dateVal) => isDateEqual(date, dateVal))) {
        const value = modelValue.value.filter((dateVal) => !isDateEqual(dateVal, date));
        modelValue.value = !value.length ? null : value;
      } else {
        if (props.multiDatesLimit && +props.multiDatesLimit > modelValue.value.length || !props.multiDatesLimit) {
          modelValue.value.push(date);
        }
      }
    } else {
      modelValue.value = [date];
    }
  };
  const checkMinMaxRange = (secondDate) => {
    if (Array.isArray(modelValue.value) && modelValue.value[0]) {
      const absoluteDiff = differenceInCalendarDays(secondDate, modelValue.value[0]);
      const start = isDateAfter(modelValue.value[0], secondDate) ? secondDate : modelValue.value[0];
      const end = isDateAfter(secondDate, modelValue.value[0]) ? secondDate : modelValue.value[0];
      const daysInBetween = eachDayOfInterval({ start, end });
      const disabledDates = daysInBetween.filter((date) => isDisabled(date)).length;
      const diff = Math.abs(absoluteDiff < 0 ? absoluteDiff + 1 : absoluteDiff - 1) - disabledDates;
      if (props.minRange && props.maxRange)
        return diff >= +props.minRange && diff <= +props.maxRange;
      if (props.minRange)
        return diff >= +props.minRange;
      if (props.maxRange)
        return diff <= +props.maxRange;
    }
    return true;
  };
  const getRangeWithFixedDate = (date) => {
    if (Array.isArray(modelValue.value) && modelValue.value.length === 2) {
      if (props.fixedStart && (isDateAfter(date, modelValue.value[0]) || isDateEqual(date, modelValue.value[0]))) {
        return [modelValue.value[0], date];
      }
      if (props.fixedEnd && (isDateBefore(date, modelValue.value[1]) || isDateEqual(date, modelValue.value[1]))) {
        return [date, modelValue.value[1]];
      }
      return modelValue.value;
    }
    return [];
  };
  const autoApply = () => {
    if (props.autoApply) {
      emit("autoApply");
    }
  };
  const isDateRangeAllowed = (range) => {
    const datesInBetween = eachDayOfInterval({ start: range[0], end: range[1] });
    return !datesInBetween.some((date) => isDisabled(date));
  };
  const selectDate = (day, isNext = false) => {
    if (isDisabled(day.value)) {
      return;
    }
    if (!day.current && props.hideOffsetDates) {
      return;
    }
    if (props.weekPicker) {
      modelValue.value = getWeekFromDate(new Date(day.value), +props.weekStart);
      return autoApply();
    }
    if (!props.range && !isNumberArray(hours.value) && !isNumberArray(minutes.value)) {
      const date = setDateTime(new Date(day.value), hours.value, minutes.value, getSecondsValue());
      if (props.multiDates) {
        handleMultiDateSelect(date);
      } else {
        modelValue.value = date;
      }
      updateFlow();
      autoApply();
    } else if (isNumberArray(hours.value) && isNumberArray(minutes.value) && !props.multiDates) {
      let rangeDate = modelValue.value ? modelValue.value.slice() : [];
      if (rangeDate.length === 2 && !(props.fixedStart || props.fixedEnd)) {
        rangeDate = [];
      }
      if (props.autoRange) {
        const autoRange = [new Date(day.value), addDays(new Date(day.value), +props.autoRange)];
        if (isDateRangeAllowed(autoRange)) {
          if (isNext) {
            handleNextCalendarAutoRange(day.value);
          }
          rangeDate = autoRange;
        }
      } else if (props.fixedStart || props.fixedEnd) {
        rangeDate = getRangeWithFixedDate(new Date(day.value));
      } else {
        if (!rangeDate[0]) {
          rangeDate[0] = new Date(day.value);
        } else if (checkMinMaxRange(new Date(day.value))) {
          if (isDateBefore(new Date(day.value), new Date(rangeDate[0]))) {
            rangeDate.unshift(new Date(day.value));
          } else {
            rangeDate[1] = new Date(day.value);
          }
        }
      }
      if (rangeDate.length) {
        if (rangeDate[0] && !rangeDate[1]) {
          rangeDate[0] = setDateTime(rangeDate[0], hours.value[0], minutes.value[0], getSecondsValue());
        } else {
          rangeDate[0] = setDateTime(rangeDate[0], hours.value[0], minutes.value[0], getSecondsValue());
          rangeDate[1] = setDateTime(rangeDate[1], hours.value[1], minutes.value[1], getSecondsValue(false));
          updateFlow();
        }
        modelValue.value = rangeDate;
        if (rangeDate[0] && rangeDate[1] && props.autoApply) {
          emit("autoApply");
        }
      }
    }
  };
  const getWeekNum = (days) => {
    const firstCurrentData = days.find((day) => day.current);
    if (firstCurrentData) {
      return getISOWeek(firstCurrentData.value);
    }
    return "";
  };
  const setHoverDate = (day) => {
    if (!day.current && props.hideOffsetDates) {
      return;
    }
    hoveredDate.value = day.value;
  };
  const isHoverRangeEnd = (day) => {
    if (props.autoRange || props.weekPicker) {
      if (hoveredDate.value) {
        if (props.hideOffsetDates && !day.current)
          return false;
        const rangeEnd = addDays(hoveredDate.value, +props.autoRange);
        const range = getWeekFromDate(new Date(hoveredDate.value), +props.weekStart);
        return props.weekPicker ? isDateEqual(range[1], new Date(day.value)) : isDateEqual(rangeEnd, new Date(day.value));
      }
      return false;
    }
    return false;
  };
  const isAutoRangeInBetween = (day) => {
    if (props.autoRange || props.weekPicker) {
      if (hoveredDate.value) {
        const rangeEnd = addDays(hoveredDate.value, +props.autoRange);
        if (props.hideOffsetDates && !day.current)
          return false;
        const range = getWeekFromDate(new Date(hoveredDate.value), +props.weekStart);
        return props.weekPicker ? isDateAfter(day.value, range[0]) && isDateBefore(day.value, range[1]) : isDateAfter(day.value, hoveredDate.value) && isDateBefore(day.value, rangeEnd);
      }
      return false;
    }
    return false;
  };
  const isAutoRangeStart = (day) => {
    if (props.autoRange || props.weekPicker) {
      if (hoveredDate.value) {
        if (props.hideOffsetDates && !day.current)
          return false;
        const range = getWeekFromDate(new Date(hoveredDate.value), +props.weekStart);
        return props.weekPicker ? isDateEqual(range[0], day.value) : isDateEqual(hoveredDate.value, day.value);
      }
      return false;
    }
    return false;
  };
  const autoChangeMultiCalendars = (instance) => {
    for (let i = instance - 1; i >= 0; i--) {
      const date = subMonths(set(new Date(), { month: month.value(i + 1), year: year.value(i + 1) }), 1);
      setCalendarMonthYear(i, getMonth(date), getYear(date));
    }
    for (let i = instance + 1; i <= props.multiCalendars - 1; i++) {
      const date = addMonths(set(new Date(), { month: month.value(i - 1), year: year.value(i - 1) }), 1);
      setCalendarMonthYear(i, getMonth(date), getYear(date));
    }
  };
  const getMonthYearValue = (instance) => {
    return setDateMonthOrYear(new Date(), month.value(instance), year.value(instance));
  };
  const updateMonthYear = (instance, val) => {
    const isValueChange = props.monthPicker ? month.value(instance) !== val.month : year.value(instance) !== val.year;
    setCalendarMonth(instance, val.month);
    setCalendarYear(instance, val.year);
    if (props.multiCalendars && !props.multiCalendarsSolo) {
      autoChangeMultiCalendars(instance);
    }
    if (props.monthPicker || props.yearPicker) {
      if (props.range) {
        if (isValueChange) {
          let rangeDate = modelValue.value ? modelValue.value.slice() : [];
          if (rangeDate.length === 2 && rangeDate[1] !== null) {
            rangeDate = [];
          }
          if (!rangeDate.length) {
            rangeDate = [getMonthYearValue(instance)];
          } else {
            if (isDateBefore(getMonthYearValue(instance), rangeDate[0])) {
              rangeDate.unshift(getMonthYearValue(instance));
            } else {
              rangeDate[1] = getMonthYearValue(instance);
            }
          }
          modelValue.value = rangeDate;
        }
      } else {
        modelValue.value = getMonthYearValue(instance);
      }
    }
    updateFlow();
    emit("updateMonthYear", { instance, month: val.month, year: val.year });
    triggerCalendarTransition(props.multiCalendarsSolo ? instance : void 0);
  };
  const getSetDateTime = (dateValue) => {
    return setDateTime(dateValue, hours.value, minutes.value, getSecondsValue());
  };
  const handleTimeUpdate = (dateValue) => {
    if (isModelValueRange(dateValue) && isModelValueRange(modelValue.value) && isNumberArray(hours.value) && isNumberArray(minutes.value)) {
      if (dateValue[0] && modelValue.value[0]) {
        modelValue.value[0] = setDateTime(dateValue[0], hours.value[0], minutes.value[0], getSecondsValue());
      }
      if (dateValue[1] && modelValue.value[1]) {
        modelValue.value[1] = setDateTime(dateValue[1], hours.value[1], minutes.value[1], getSecondsValue(false));
      }
    } else if (props.multiDates && Array.isArray(modelValue.value)) {
      modelValue.value[modelValue.value.length - 1] = getSetDateTime(dateValue);
    } else if (!props.range && !isRange(dateValue)) {
      modelValue.value = getSetDateTime(dateValue);
    }
    emit("timeUpdate");
  };
  const updateTime = (value, isHours = true, isSeconds = false) => {
    const hoursCp = isHours ? value : hours.value;
    const minutesCp = !isHours && !isSeconds ? value : minutes.value;
    const secondsCp = isSeconds ? value : seconds.value;
    if (props.range && isRange(modelValue.value) && isNumberArray(hoursCp) && isNumberArray(minutesCp) && isNumberArray(secondsCp) && !props.disableTimeRangeValidation) {
      const setTime = (index) => setDateTime(modelValue.value[index], hoursCp[index], minutesCp[index], secondsCp[index]);
      const resetMilliseconds = (index) => setMilliseconds(modelValue.value[index], 0);
      if (isDateEqual(modelValue.value[0], modelValue.value[1]) && (isAfter(setTime(0), resetMilliseconds(1)) || isBefore(setTime(1), resetMilliseconds(0)))) {
        return;
      }
    }
    hours.value = hoursCp;
    minutes.value = minutesCp;
    seconds.value = secondsCp;
    if (modelValue.value) {
      if (props.multiDates) {
        const lastEntry = multiDatesLast();
        if (lastEntry) {
          handleTimeUpdate(lastEntry);
        }
      } else {
        handleTimeUpdate(modelValue.value);
      }
    } else if (props.timePicker) {
      handleTimeUpdate(props.range ? [new Date(), new Date()] : new Date());
    }
    updateFlow();
  };
  const clearHoverDate = () => {
    hoveredDate.value = null;
  };
  const checkRangeDirection = (isStart) => {
    if (modelValueIsRange(modelValue.value, props.range) && modelValue.value[0] && hoveredDate.value) {
      return isStart ? isDateAfter(hoveredDate.value, modelValue.value[0]) : isDateBefore(hoveredDate.value, modelValue.value[0]);
    }
    return true;
  };
  const rangeActiveStartEnd = (day, isStart = true) => {
    if ((props.range || props.weekPicker) && isRange(modelValue.value)) {
      if (props.hideOffsetDates && !day.current)
        return false;
      return isDateEqual(new Date(day.value), modelValue.value[isStart ? 0 : 1]);
    } else if (props.range) {
      return isDateEqual(new Date(day.value), modelValue.value && Array.isArray(modelValue.value) ? isStart ? modelValue.value[0] || null : modelValue.value[1] : null) && (isStart ? !isDateBefore(hoveredDate.value || null, Array.isArray(modelValue.value) ? modelValue.value[0] : null) : true) || isDateEqual(day.value, Array.isArray(modelValue.value) ? modelValue.value[0] : null) && checkRangeDirection(isStart);
    }
    return false;
  };
  const isHoverDate = (disabled, calendarDay) => {
    return Array.isArray(props.internalModelValue) && props.internalModelValue.length || props.weekPicker ? false : !disabled && !isActiveDate(calendarDay) && !(!calendarDay.current && props.hideOffsetDates) && (props.range ? !rangeActiveStartEnd(calendarDay) && !rangeActiveStartEnd(calendarDay, false) : true);
  };
  const isHoverDateStartEnd = (dateIsHovered, calendarDay, start) => {
    if (Array.isArray(props.internalModelValue) && props.internalModelValue[0] && props.internalModelValue.length === 1) {
      if (dateIsHovered) {
        return false;
      }
      return start ? isDateAfter(props.internalModelValue[0], calendarDay.value) : isDateBefore(props.internalModelValue[0], calendarDay.value);
    }
    return false;
  };
  const monthYearSelect = (isYear = false) => {
    if (props.autoApply && (props.monthPicker || props.yearPicker)) {
      nextTick().then(() => {
        if (props.range) {
          emit("autoApply", isYear || !modelValue.value || modelValue.value.length === 1);
        } else {
          emit("autoApply", isYear);
        }
      });
    }
  };
  const autoChangeMonth = (increment, instance) => {
    const initialDate = set(new Date(), { month: month.value(instance), year: year.value(instance) });
    const date = increment < 0 ? addMonths(initialDate, 1) : subMonths(initialDate, 1);
    if (validateMonthYearInRange(props.minDate, props.maxDate, getMonth(date), getYear(date), increment < 0, props.preventMinMaxNavigation)) {
      setCalendarMonthYear(instance, getMonth(date), getYear(date));
      if (props.multiCalendars && !props.multiCalendarsSolo) {
        autoChangeMultiCalendars(instance);
      }
      triggerCalendarTransition();
    }
  };
  const handleScroll = (event, instance) => {
    if (props.monthChangeOnScroll) {
      autoChangeMonth(props.monthChangeOnScroll !== "inverse" ? -event.deltaY : event.deltaY, instance);
    }
  };
  const handleArrow = (arrow, instance, vertical = false) => {
    if (props.monthChangeOnArrows && props.vertical === vertical) {
      handleSwipe(arrow, instance);
    }
  };
  const handleSwipe = (direction, instance) => {
    autoChangeMonth(direction === "right" ? -1 : 1, instance);
  };
  const getMarker = (date) => props.markers.find((marker) => isDateEqual(sanitizeDate(date.value), sanitizeDate(marker.date)));
  const selectCurrentDate = () => {
    if (!props.range) {
      emit("update:internalModelValue", new Date());
    } else if (modelValueIsRange(modelValue.value, props.range)) {
      if (modelValue.value && modelValue.value[0]) {
        modelValue.value = isDateBefore(new Date(), modelValue.value[0]) ? [new Date(), modelValue.value[0]] : [modelValue.value[0], new Date()];
      } else {
        modelValue.value = [new Date()];
      }
    }
    if (props.autoApply) {
      emit("selectDate");
    }
  };
  const presetDateRange = (dates) => {
    if (dates.length && dates.length <= 2 && props.range) {
      modelValue.value = dates.map((date) => new Date(date));
      if (props.autoApply) {
        emit("selectDate");
      }
    }
  };
  const triggerCalendarTransition = (instance) => {
    if (instance || instance === 0) {
      calendarRefs.value[instance].triggerTransition(month.value(instance), year.value(instance));
    } else {
      calendarRefs.value.forEach((refVal, i) => refVal.triggerTransition(month.value(i), year.value(i)));
    }
  };
  return {
    today,
    hours,
    minutes,
    seconds,
    month,
    year,
    monthYearSelect,
    isDisabled,
    updateTime,
    setHoverDate,
    getWeekNum,
    selectDate,
    rangeActive,
    isActiveDate,
    updateMonthYear,
    isHoverRangeEnd,
    isAutoRangeInBetween,
    isAutoRangeStart,
    clearHoverDate,
    rangeActiveStartEnd,
    handleScroll,
    getMarker,
    handleArrow,
    handleSwipe,
    selectCurrentDate,
    isHoverDate,
    isHoverDateStartEnd,
    presetDateRange
  };
};
const store = reactive({
  menuFocused: false,
  shiftKeyInMenu: false
});
const useStore = () => {
  const setMenuFocused = (value) => {
    store.menuFocused = value;
  };
  const setShiftKey = (value) => {
    if (store.shiftKeyInMenu === value)
      return;
    store.shiftKeyInMenu = value;
  };
  const getStore = () => store;
  return {
    setMenuFocused,
    getStore,
    setShiftKey
  };
};
const _hoisted_1 = ["id", "aria-label", "onKeydown"];
const _hoisted_2 = {
  key: 0,
  class: "dp__preset_ranges"
};
const _hoisted_3 = ["onClick"];
const _hoisted_4 = {
  key: 1,
  class: "dp__now_wrap"
};
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "DatepickerMenu",
  props: {
    ...MenuProps,
    ...SharedProps,
    ...ControlProps,
    internalModelValue: { type: [Date, Array], default: null },
    multiCalendars: { type: Number, default: 0 },
    openOnTop: { type: Boolean, default: false }
  },
  emits: [
    "update:internalModelValue",
    "closePicker",
    "selectDate",
    "dpOpen",
    "autoApply",
    "timeUpdate",
    "flow-step",
    "updateMonthYear"
  ],
  setup(__props, { emit }) {
    const props = __props;
    const slots2 = useSlots();
    const calendarWrapperRef = ref(null);
    const childrenMounted = reactive({
      timePicker: !!(!props.enableTimePicker || props.timePicker || props.monthPicker),
      monthYearInput: !!props.timePicker,
      calendar: false
    });
    const monthYearPickerRefs = ref([]);
    const calendarRefs = ref([]);
    const timePickerRef = ref(null);
    const dpMenuRef = ref(null);
    const calendarWidth = ref(0);
    const menuMount = ref(false);
    const flowStep = ref(0);
    const transitions = inject(transitionsKey);
    const ariaLabels = inject(ariaLabelsKey);
    const arrowNavigation = inject(arrowNavigationKey);
    const { setMenuFocused, setShiftKey, getStore } = useStore();
    onMounted(() => {
      var _a;
      menuMount.value = true;
      if (!((_a = props.presetRanges) == null ? void 0 : _a.length)) {
        getCalendarWidth();
      }
      const menu = unrefElement(dpMenuRef);
      if (menu && !props.textInput && !props.inline) {
        setMenuFocused(true);
        focusMenu();
      }
      if (menu) {
        const stopDefault = (event) => {
          event.stopImmediatePropagation();
          event.stopPropagation();
        };
        menu.addEventListener("pointerdown", stopDefault);
        menu.addEventListener("mousedown", stopDefault);
      }
      document.addEventListener("resize", getCalendarWidth);
    });
    onUnmounted(() => {
      document.removeEventListener("resize", getCalendarWidth);
    });
    const { arrowRight, arrowLeft, arrowDown, arrowUp } = useArrowNavigation();
    const focusMenu = () => {
      const menu = unrefElement(dpMenuRef);
      if (menu) {
        menu.focus({ preventScroll: true });
      }
    };
    const updateFlowStep = () => {
      var _a;
      if (((_a = props.flow) == null ? void 0 : _a.length) && flowStep.value !== -1) {
        flowStep.value += 1;
        emit("flow-step", flowStep.value);
        handleFlow();
      }
    };
    const resetFlow = () => {
      flowStep.value = -1;
    };
    const {
      updateTime,
      updateMonthYear,
      today,
      month,
      year,
      hours,
      minutes,
      seconds,
      isDisabled,
      isActiveDate,
      selectDate,
      getWeekNum,
      setHoverDate,
      isHoverRangeEnd,
      isAutoRangeInBetween,
      isAutoRangeStart,
      rangeActive,
      clearHoverDate,
      rangeActiveStartEnd,
      monthYearSelect,
      handleScroll,
      handleArrow,
      handleSwipe,
      getMarker,
      selectCurrentDate,
      isHoverDateStartEnd,
      isHoverDate,
      presetDateRange
    } = useCalendar(props, emit, updateFlowStep, calendarRefs);
    const calendarSlots = mapSlots(slots2, "calendar");
    const actionSlots = mapSlots(slots2, "action");
    const timePickerSlots = mapSlots(slots2, "timePicker");
    const monthYearSlots = mapSlots(slots2, "monthYear");
    const arrowClass = computed(() => !props.openOnTop ? "dp__arrow_top" : "dp__arrow_bottom");
    const years = computed(() => {
      return getYears(props.yearRange);
    });
    const months = computed(() => {
      return getMonths(props.locale, props.monthNameFormat);
    });
    const getCalendarWidth = () => {
      const el = unrefElement(calendarWrapperRef);
      if (el) {
        calendarWidth.value = el.getBoundingClientRect().width;
      }
    };
    const dates = computed(() => (instance) => getCalendarDays(month.value(instance), year.value(instance), +props.weekStart, props.hideOffsetDates));
    const calendarAmm = computed(() => props.multiCalendars > 0 && props.range ? [...Array(props.multiCalendars).keys()] : [0]);
    const isFirstInstance = computed(() => (instance) => instance === 1);
    const specificMode = computed(() => props.monthPicker || props.timePicker || props.yearPicker);
    const menuCalendarClassWrapper = computed(() => ({
      dp__flex_display: props.multiCalendars > 0
    }));
    const calendarInstanceClassWrapper = computed(() => ({
      dp__instance_calendar: props.multiCalendars > 0
    }));
    const disabledReadonlyOverlay = computed(() => ({
      dp__menu_disabled: props.disabled,
      dp__menu_readonly: props.readonly
    }));
    const mappedDates = computed(() => (instance) => mapDates(dates, instance));
    const calendarProps = computed(() => ({
      locale: props.locale,
      weekNumName: props.weekNumName,
      weekStart: props.weekStart,
      weekNumbers: props.weekNumbers,
      customProps: props.customProps,
      calendarClassName: props.calendarClassName,
      specificMode: specificMode.value,
      getWeekNum,
      multiCalendars: props.multiCalendars,
      modeHeight: props.modeHeight,
      internalModelValue: props.internalModelValue,
      noSwipe: props.noSwipe,
      vertical: props.vertical,
      dayNames: props.dayNames,
      monthChangeOnScroll: props.monthChangeOnScroll
    }));
    const dpMenuClass = computed(() => ({
      dp__menu: true,
      dp__menu_index: !props.inline,
      dp__relative: props.inline,
      [props.menuClassName]: !!props.menuClassName
    }));
    const isSingleInModelAuto = () => {
      if (props.modelAuto && Array.isArray(props.internalModelValue)) {
        return !!props.internalModelValue[0];
      }
      return false;
    };
    const isModelAutoActive = () => {
      if (props.modelAuto)
        return isModelAuto(props.internalModelValue);
      return true;
    };
    const mapDates = (dates2, instance) => {
      return dates2.value(instance).map((date) => {
        return {
          ...date,
          days: date.days.map((calendarDay) => {
            const disabled = isDisabled(calendarDay.value);
            const dateHover = isHoverDate(disabled, calendarDay);
            const isActive = props.range ? props.modelAuto ? isSingleInModelAuto() && isActiveDate(calendarDay) : false : isActiveDate(calendarDay);
            const isBetween = (props.range || props.weekPicker) && (props.multiCalendars > 0 ? calendarDay.current : true) && !disabled && isModelAutoActive() && !(!calendarDay.current && props.hideOffsetDates) && !isActiveDate(calendarDay) ? rangeActive(calendarDay) : false;
            calendarDay.marker = getMarker(calendarDay);
            calendarDay.classData = {
              dp__cell_offset: !calendarDay.current,
              dp__pointer: !disabled && !(!calendarDay.current && props.hideOffsetDates),
              dp__active_date: isActive,
              dp__date_hover: dateHover,
              dp__date_hover_start: isHoverDateStartEnd(dateHover, calendarDay, true),
              dp__date_hover_end: isHoverDateStartEnd(dateHover, calendarDay, false),
              dp__range_between: isBetween && !props.weekPicker,
              dp__range_between_week: isBetween && props.weekPicker,
              dp__today: !props.noToday && isDateEqual(calendarDay.value, today.value) && calendarDay.current,
              dp__cell_disabled: disabled,
              dp__cell_auto_range: isAutoRangeInBetween(calendarDay),
              dp__cell_auto_range_start: isAutoRangeStart(calendarDay),
              dp__cell_auto_range_end: isHoverRangeEnd(calendarDay),
              dp__range_start: props.multiCalendars > 0 ? calendarDay.current && rangeActiveStartEnd(calendarDay) && isModelAutoActive() : rangeActiveStartEnd(calendarDay) && isModelAutoActive(),
              dp__range_end: props.multiCalendars > 0 ? calendarDay.current && rangeActiveStartEnd(calendarDay, false) && isModelAutoActive() : rangeActiveStartEnd(calendarDay, false) && isModelAutoActive(),
              [props.calendarCellClassName]: !!props.calendarCellClassName,
              dp__cell_highlight: props.highlight ? matchDate(calendarDay.value, props.highlight) && !isActive : false
            };
            return calendarDay;
          })
        };
      });
    };
    const handleDpMenuClick = (e) => {
      e.stopPropagation();
      e.preventDefault();
      e.stopImmediatePropagation();
    };
    const handleEsc = () => {
      if (props.escClose) {
        emit("closePicker");
      }
    };
    const handleSpace = (event) => {
      event.stopImmediatePropagation();
      event.preventDefault();
      if (props.spaceConfirm) {
        emit("selectDate");
      }
    };
    const childMount = (cmp) => {
      var _a;
      if ((_a = props.flow) == null ? void 0 : _a.length) {
        childrenMounted[cmp] = true;
        if (!Object.keys(childrenMounted).filter((key) => !childrenMounted[key]).length) {
          handleFlow();
        }
      }
    };
    const handleFlow = () => {
      if (props.flow[flowStep.value] === "month") {
        if (monthYearPickerRefs.value[0]) {
          monthYearPickerRefs.value[0].toggleMonthPicker(true);
        }
      }
      if (props.flow[flowStep.value] === "year") {
        if (monthYearPickerRefs.value) {
          monthYearPickerRefs.value[0].toggleYearPicker(true);
        }
      }
      if (props.flow[flowStep.value] === "calendar") {
        if (timePickerRef.value) {
          timePickerRef.value.toggleTimePicker(false, true);
        }
      }
      if (props.flow[flowStep.value] === "time") {
        if (timePickerRef.value) {
          timePickerRef.value.toggleTimePicker(true, true);
        }
      }
      const flowValue = props.flow[flowStep.value];
      if (flowValue === "hours" || flowValue === "minutes" || flowValue === "seconds") {
        if (timePickerRef.value) {
          timePickerRef.value.toggleTimePicker(true, true, flowValue);
        }
      }
    };
    const handleArrowKey = (arrow) => {
      if (arrowNavigation == null ? void 0 : arrowNavigation.value) {
        if (arrow === "up")
          return arrowUp();
        if (arrow === "down")
          return arrowDown();
        if (arrow === "left")
          return arrowLeft();
        if (arrow === "right")
          return arrowRight();
      } else {
        if (arrow === "left" || arrow === "up") {
          handleArrow("left", 0, arrow === "up");
        } else {
          handleArrow("right", 0, arrow === "down");
        }
      }
    };
    const checkShiftKey = (ev) => {
      setShiftKey(ev.shiftKey);
      if (!props.disableMonthYearSelect && ev.code === "Tab") {
        if (ev.target.classList.contains("dp__menu") && getStore().shiftKeyInMenu) {
          ev.preventDefault();
          ev.stopImmediatePropagation();
          emit("closePicker");
        }
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Transition, {
        appear: "",
        name: unref(transitions).menuAppear,
        mode: "out-in",
        css: !!unref(transitions)
      }, {
        default: withCtx(() => [
          createElementVNode("div", {
            id: _ctx.uid ? `dp-menu-${_ctx.uid}` : void 0,
            tabindex: "0",
            ref_key: "dpMenuRef",
            ref: dpMenuRef,
            role: "dialog",
            "aria-label": unref(ariaLabels).menu,
            class: normalizeClass(unref(dpMenuClass)),
            onMouseleave: _cache[11] || (_cache[11] = (...args) => unref(clearHoverDate) && unref(clearHoverDate)(...args)),
            onClick: handleDpMenuClick,
            onKeydown: [
              withKeys(handleEsc, ["esc"]),
              withKeys(handleSpace, ["space"]),
              _cache[12] || (_cache[12] = withKeys(withModifiers(($event) => handleArrowKey("left"), ["prevent"]), ["left"])),
              _cache[13] || (_cache[13] = withKeys(withModifiers(($event) => handleArrowKey("up"), ["prevent"]), ["up"])),
              _cache[14] || (_cache[14] = withKeys(withModifiers(($event) => handleArrowKey("down"), ["prevent"]), ["down"])),
              _cache[15] || (_cache[15] = withKeys(withModifiers(($event) => handleArrowKey("right"), ["prevent"]), ["right"])),
              checkShiftKey
            ]
          }, [
            (_ctx.disabled || _ctx.readonly) && _ctx.inline ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(unref(disabledReadonlyOverlay))
            }, null, 2)) : createCommentVNode("", true),
            !_ctx.inline ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass(unref(arrowClass))
            }, null, 2)) : createCommentVNode("", true),
            createElementVNode("div", {
              class: normalizeClass(_ctx.presetRanges.length ? "dp__menu_content_wrapper" : null)
            }, [
              _ctx.presetRanges.length ? (openBlock(), createElementBlock("div", _hoisted_2, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.presetRanges, (preset, i) => {
                  return openBlock(), createElementBlock("div", {
                    key: i,
                    style: normalizeStyle(preset.style || {}),
                    class: "dp__preset_range",
                    onClick: ($event) => unref(presetDateRange)(preset.range)
                  }, toDisplayString(preset.label), 13, _hoisted_3);
                }), 128))
              ])) : createCommentVNode("", true),
              createElementVNode("div", {
                class: "dp__instance_calendar",
                ref_key: "calendarWrapperRef",
                ref: calendarWrapperRef,
                role: "document"
              }, [
                createElementVNode("div", {
                  class: normalizeClass(unref(menuCalendarClassWrapper))
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(calendarAmm), (instance, i) => {
                    return openBlock(), createElementBlock("div", {
                      key: instance,
                      class: normalizeClass(unref(calendarInstanceClassWrapper))
                    }, [
                      !_ctx.disableMonthYearSelect && !_ctx.timePicker ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.monthYearComponent ? _ctx.monthYearComponent : _sfc_main$2), mergeProps({
                        key: 0,
                        ref_for: true,
                        ref: (el) => {
                          if (el)
                            monthYearPickerRefs.value[i] = el;
                        }
                      }, {
                        months: unref(months),
                        years: unref(years),
                        filters: _ctx.filters,
                        monthPicker: _ctx.monthPicker,
                        month: unref(month)(instance),
                        year: unref(year)(instance),
                        customProps: _ctx.customProps,
                        multiCalendars: __props.multiCalendars,
                        multiCalendarsSolo: _ctx.multiCalendarsSolo,
                        instance,
                        minDate: _ctx.minDate,
                        maxDate: _ctx.maxDate,
                        preventMinMaxNavigation: _ctx.preventMinMaxNavigation,
                        internalModelValue: __props.internalModelValue,
                        range: _ctx.range,
                        reverseYears: _ctx.reverseYears,
                        vertical: _ctx.vertical,
                        yearPicker: _ctx.yearPicker
                      }, {
                        onMount: _cache[0] || (_cache[0] = ($event) => childMount("monthYearInput")),
                        onResetFlow: resetFlow,
                        onUpdateMonthYear: ($event) => unref(updateMonthYear)(instance, $event),
                        onMonthYearSelect: unref(monthYearSelect),
                        onOverlayClosed: focusMenu
                      }), createSlots({ _: 2 }, [
                        renderList(unref(monthYearSlots), (slot, j) => {
                          return {
                            name: slot,
                            fn: withCtx((args) => [
                              renderSlot(_ctx.$slots, slot, normalizeProps(guardReactiveProps(args)))
                            ])
                          };
                        })
                      ]), 1040, ["onUpdateMonthYear", "onMonthYearSelect"])) : createCommentVNode("", true),
                      createVNode(_sfc_main$9, mergeProps({
                        ref_for: true,
                        ref: (el) => {
                          if (el)
                            calendarRefs.value[i] = el;
                        }
                      }, unref(calendarProps), {
                        "flow-step": flowStep.value,
                        "onUpdate:flow-step": _cache[1] || (_cache[1] = ($event) => flowStep.value = $event),
                        instance,
                        "mapped-dates": unref(mappedDates)(instance),
                        month: unref(month)(instance),
                        year: unref(year)(instance),
                        onSelectDate: ($event) => unref(selectDate)($event, !unref(isFirstInstance)(instance)),
                        onSetHoverDate: _cache[2] || (_cache[2] = ($event) => unref(setHoverDate)($event)),
                        onHandleScroll: ($event) => unref(handleScroll)($event, instance),
                        onHandleSwipe: ($event) => unref(handleSwipe)($event, instance),
                        onMount: _cache[3] || (_cache[3] = ($event) => childMount("calendar")),
                        onResetFlow: resetFlow
                      }), createSlots({ _: 2 }, [
                        renderList(unref(calendarSlots), (slot, j) => {
                          return {
                            name: slot,
                            fn: withCtx((args) => [
                              renderSlot(_ctx.$slots, slot, normalizeProps(guardReactiveProps({ ...args })))
                            ])
                          };
                        })
                      ]), 1040, ["flow-step", "instance", "mapped-dates", "month", "year", "onSelectDate", "onHandleScroll", "onHandleSwipe"])
                    ], 2);
                  }), 128))
                ], 2),
                createElementVNode("div", null, [
                  _ctx.enableTimePicker && !_ctx.monthPicker && !_ctx.weekPicker ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.timePickerComponent ? _ctx.timePickerComponent : _sfc_main$5), mergeProps({
                    key: 0,
                    ref_key: "timePickerRef",
                    ref: timePickerRef
                  }, {
                    is24: _ctx.is24,
                    hoursIncrement: _ctx.hoursIncrement,
                    minutesIncrement: _ctx.minutesIncrement,
                    hoursGridIncrement: _ctx.hoursGridIncrement,
                    secondsIncrement: _ctx.secondsIncrement,
                    minutesGridIncrement: _ctx.minutesGridIncrement,
                    secondsGridIncrement: _ctx.secondsGridIncrement,
                    noHoursOverlay: _ctx.noHoursOverlay,
                    noMinutesOverlay: _ctx.noMinutesOverlay,
                    noSecondsOverlay: _ctx.noSecondsOverlay,
                    range: _ctx.range,
                    filters: _ctx.filters,
                    timePicker: _ctx.timePicker,
                    hours: unref(hours),
                    minutes: unref(minutes),
                    seconds: unref(seconds),
                    customProps: _ctx.customProps,
                    enableSeconds: _ctx.enableSeconds,
                    fixedStart: _ctx.fixedStart,
                    fixedEnd: _ctx.fixedEnd,
                    modelAuto: _ctx.modelAuto,
                    internalModelValue: __props.internalModelValue
                  }, {
                    onMount: _cache[4] || (_cache[4] = ($event) => childMount("timePicker")),
                    "onUpdate:hours": _cache[5] || (_cache[5] = ($event) => unref(updateTime)($event)),
                    "onUpdate:minutes": _cache[6] || (_cache[6] = ($event) => unref(updateTime)($event, false)),
                    "onUpdate:seconds": _cache[7] || (_cache[7] = ($event) => unref(updateTime)($event, false, true)),
                    onResetFlow: resetFlow,
                    onOverlayClosed: focusMenu
                  }), createSlots({ _: 2 }, [
                    renderList(unref(timePickerSlots), (slot, i) => {
                      return {
                        name: slot,
                        fn: withCtx((args) => [
                          renderSlot(_ctx.$slots, slot, normalizeProps(guardReactiveProps(args)))
                        ])
                      };
                    })
                  ]), 1040)) : createCommentVNode("", true)
                ])
              ], 512),
              _ctx.showNowButton ? (openBlock(), createElementBlock("div", _hoisted_4, [
                _ctx.$slots["now-button"] ? renderSlot(_ctx.$slots, "now-button", {
                  key: 0,
                  selectCurrentDate: unref(selectCurrentDate)
                }) : createCommentVNode("", true),
                !_ctx.$slots["now-button"] ? (openBlock(), createElementBlock("button", {
                  key: 1,
                  type: "button",
                  role: "button",
                  class: "dp__now_button",
                  onClick: _cache[8] || (_cache[8] = (...args) => unref(selectCurrentDate) && unref(selectCurrentDate)(...args))
                }, toDisplayString(_ctx.nowButtonLabel), 1)) : createCommentVNode("", true)
              ])) : createCommentVNode("", true)
            ], 2),
            !_ctx.autoApply || _ctx.keepActionRow ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.actionRowComponent ? _ctx.actionRowComponent : _sfc_main$8), mergeProps({ key: 2 }, {
              calendarWidth: calendarWidth.value,
              selectText: _ctx.selectText,
              cancelText: _ctx.cancelText,
              internalModelValue: __props.internalModelValue,
              range: _ctx.range,
              previewFormat: _ctx.previewFormat,
              inline: _ctx.inline,
              monthPicker: _ctx.monthPicker,
              timePicker: _ctx.timePicker,
              customProps: _ctx.customProps,
              multiCalendars: __props.multiCalendars,
              menuMount: menuMount.value,
              maxTime: _ctx.maxTime,
              minTime: _ctx.minTime,
              enableTimePicker: _ctx.enableTimePicker,
              minDate: _ctx.minDate,
              maxDate: _ctx.maxDate,
              multiDates: _ctx.multiDates,
              modelAuto: _ctx.modelAuto,
              partialRange: _ctx.partialRange
            }, {
              onClosePicker: _cache[9] || (_cache[9] = ($event) => _ctx.$emit("closePicker")),
              onSelectDate: _cache[10] || (_cache[10] = ($event) => _ctx.$emit("selectDate"))
            }), createSlots({ _: 2 }, [
              renderList(unref(actionSlots), (slot, i) => {
                return {
                  name: slot,
                  fn: withCtx((args) => [
                    renderSlot(_ctx.$slots, slot, normalizeProps(guardReactiveProps({ ...args })))
                  ])
                };
              })
            ]), 1040)) : createCommentVNode("", true)
          ], 42, _hoisted_1)
        ]),
        _: 3
      }, 8, ["name", "css"]);
    };
  }
});
var OpenPosition = /* @__PURE__ */ ((OpenPosition2) => {
  OpenPosition2["center"] = "center";
  OpenPosition2["left"] = "left";
  OpenPosition2["right"] = "right";
  return OpenPosition2;
})(OpenPosition || {});
const usePosition = (openPosition, altPosition, autoPosition, menuRef, inputRef, inline, emit) => {
  const menuPosition = ref({ top: "0", left: "0", transform: "none" });
  const openOnTop = ref(false);
  const diagonal = 10;
  const maxHeight = 390;
  const getOffset = (el) => {
    const rect = el.getBoundingClientRect();
    return {
      left: rect.left + window.scrollX,
      top: rect.top + window.scrollY
    };
  };
  const getOffsetAlt = (el) => {
    const rect = el.getBoundingClientRect();
    let x = 0;
    let y = 0;
    while (el && !isNaN(el.offsetLeft) && !isNaN(el.offsetTop)) {
      x += el.offsetLeft - el.scrollLeft;
      y = rect.top + el.scrollTop;
      el = el.offsetParent;
    }
    return { top: y, left: x };
  };
  const setPositionRight = (left, width) => {
    menuPosition.value.left = `${left + width}px`;
    menuPosition.value.transform = `translateX(-100%)`;
  };
  const setPositionLeft = (left) => {
    menuPosition.value.left = `${left}px`;
    menuPosition.value.transform = `translateX(0)`;
  };
  const setPositioning = (left, width) => {
    if (openPosition === OpenPosition.left) {
      setPositionLeft(left);
    }
    if (openPosition === OpenPosition.right) {
      setPositionRight(left, width);
    }
    if (openPosition === OpenPosition.center) {
      menuPosition.value.left = `${left + width / 2}px`;
      menuPosition.value.transform = `translateX(-50%)`;
    }
  };
  const setInitialPosition = () => {
    const inputEl = unrefElement(inputRef);
    if (inputEl) {
      const fullHeight = window.innerHeight;
      const { top: offset } = altPosition ? getOffsetAlt(inputEl) : getOffset(inputEl);
      const { left, width, top, height } = inputEl.getBoundingClientRect();
      const freeBottom = fullHeight - top - height;
      menuPosition.value.top = top > freeBottom ? `${offset - maxHeight}px` : `${offset}px`;
      setPositioning(left, width);
    }
  };
  const setMenuPosition = (recalculate = true) => {
    if (!inline) {
      const el = unrefElement(inputRef);
      if (altPosition && typeof altPosition !== "boolean") {
        menuPosition.value = altPosition(el);
      } else if (el) {
        const { left, width, height } = el.getBoundingClientRect();
        const { top: offset } = altPosition ? getOffsetAlt(el) : getOffset(el);
        menuPosition.value.top = `${height + offset + diagonal}px`;
        setPositioning(left, width);
        if (recalculate && autoPosition) {
          recalculatePosition();
        }
      }
    }
  };
  const recalculatePosition = () => {
    const el = unrefElement(inputRef);
    if (el && autoPosition && !inline) {
      const { height: inputHeight, top, left: inputLeft, width } = el.getBoundingClientRect();
      const { top: offset } = altPosition ? getOffsetAlt(el) : getOffset(el);
      const fullHeight = window.innerHeight;
      const freeSpaceBottom = fullHeight - top - inputHeight;
      const menuEl = unrefElement(menuRef);
      if (menuEl) {
        const { height, left, right } = menuEl.getBoundingClientRect();
        const menuHeight = height + inputHeight;
        if (menuHeight > top && menuHeight > freeSpaceBottom) {
          if (top < freeSpaceBottom) {
            setMenuPosition(false);
            openOnTop.value = false;
          }
        } else {
          if (menuHeight > freeSpaceBottom) {
            menuPosition.value.top = `${offset - height - diagonal}px`;
            openOnTop.value = true;
          } else {
            setMenuPosition(false);
            openOnTop.value = false;
          }
        }
        if (left < 0) {
          setPositionLeft(inputLeft);
        } else if (right > document.documentElement.clientWidth) {
          setPositionRight(inputLeft, width);
        }
      }
    }
    emit("recalculatePosition");
  };
  return { openOnTop, menuPosition, setMenuPosition, setInitialPosition, recalculatePosition };
};
const useExternalInternalMapper = (format2, timePicker, monthPicker, range, partialRange, is24, enableTimePicker, enableSeconds, formatLocale, multiDates, utc, weekPicker, yearPicker, textInputOptions, modelType, modelAuto, emit) => {
  const inputValue = ref("");
  const internalModelValue = ref();
  watch(internalModelValue, () => {
    emit("internalModelChange", internalModelValue.value);
  });
  const mapArrayToValue = (value) => {
    return [parseModelType(value[0]), value[1] ? parseModelType(value[1]) : null];
  };
  const parseExternalModelValue = (value) => {
    let mappedDate = null;
    if (value) {
      if (timePicker) {
        if (isTimeArray(value) && "hours" in value[0] && "minutes" in value[0]) {
          mappedDate = [
            setDateTime(null, +value[0].hours, +value[0].minutes, +value[0].seconds),
            setDateTime(null, +value[1].hours, +value[1].minutes, +value[1].seconds)
          ];
        } else if (isTime(value)) {
          mappedDate = setDateTime(null, +value.hours, +value.minutes, +value.seconds);
        }
      } else if (monthPicker) {
        if (isMonthArray(value) && "month" in value[0] && "year" in value[0]) {
          mappedDate = [setDateMonthOrYear(null, +value[0].month, +value[0].year)];
          if (value[1]) {
            mappedDate[1] = setDateMonthOrYear(null, +value[1].month, +value[1].year);
          } else if (!value[1] && partialRange) {
            mappedDate[1] = null;
          }
        } else if (isMonth(value) && "month" in value && "year" in value) {
          mappedDate = setDateMonthOrYear(null, +value.month, +value.year);
        }
      } else if (yearPicker) {
        if (Array.isArray(value)) {
          mappedDate = [
            setYear(new Date(), value[0]),
            !value[1] && partialRange ? null : setYear(new Date(), value[1])
          ];
        } else {
          mappedDate = setYear(new Date(), value);
        }
      } else if (multiDates && Array.isArray(value)) {
        mappedDate = value.map((date) => parseModelType(date));
      } else if (weekPicker && Array.isArray(value)) {
        mappedDate = [new Date(value[0]), new Date(value[1])];
      } else if (range) {
        if (modelAuto) {
          if (Array.isArray(value)) {
            mappedDate = mapArrayToValue(value);
          } else {
            mappedDate = [parseModelType(value), null];
          }
        } else if (isRangeArray(value, partialRange)) {
          mappedDate = mapArrayToValue(value);
        }
      } else if (isSingle(value)) {
        mappedDate = parseModelType(value);
      }
    } else {
      mappedDate = null;
    }
    if (isValidDate(mappedDate)) {
      internalModelValue.value = mappedDate;
      formatInputValue();
    } else {
      internalModelValue.value = null;
      inputValue.value = "";
    }
  };
  const getPattern = () => {
    return getDefaultPattern(format2, is24, enableSeconds, monthPicker, timePicker, weekPicker, yearPicker, enableTimePicker);
  };
  const formatInputValue = () => {
    if (!internalModelValue.value) {
      inputValue.value = "";
    } else if (!format2 || typeof format2 === "string") {
      const pattern = getPattern();
      if (Array.isArray(internalModelValue.value) && multiDates) {
        inputValue.value = internalModelValue.value.map((date) => formatDate(date, pattern, formatLocale == null ? void 0 : formatLocale.value)).join("; ");
      } else {
        inputValue.value = formatDate(internalModelValue.value, pattern, formatLocale == null ? void 0 : formatLocale.value, textInputOptions == null ? void 0 : textInputOptions.rangeSeparator, modelAuto);
      }
    } else if (timePicker) {
      inputValue.value = format2(getTImeForExternal(internalModelValue.value));
    } else if (monthPicker) {
      inputValue.value = format2(getMonthValForExternal(internalModelValue.value));
    } else {
      inputValue.value = format2(internalModelValue.value);
    }
  };
  const checkBeforeEmit = () => {
    if (internalModelValue.value) {
      if (range) {
        if (partialRange)
          return internalModelValue.value.length >= 1;
        return internalModelValue.value.length === 2;
      }
      return !!internalModelValue.value;
    }
    return false;
  };
  const parseModelType = (value) => {
    if (utc) {
      const toDate = new Date(value);
      return utc === "preserve" ? new Date(toDate.getTime() + toDate.getTimezoneOffset() * 6e4) : toDate;
    }
    if (modelType) {
      if (modelType === "date" || modelType === "timestamp")
        return new Date(value);
      if (modelType === "format" && (typeof format2 === "string" || !format2))
        return parse(value, getPattern(), new Date());
      return parse(value, modelType, new Date());
    }
    return new Date(value);
  };
  const getModelValueType = (val) => {
    if (modelType) {
      if (modelType === "timestamp")
        return +val;
      if (modelType === "format" && (typeof format2 === "string" || !format2))
        return formatDate(val, getPattern(), formatLocale == null ? void 0 : formatLocale.value, textInputOptions == null ? void 0 : textInputOptions.rangeSeparator);
      return formatDate(val, modelType, formatLocale == null ? void 0 : formatLocale.value, textInputOptions == null ? void 0 : textInputOptions.rangeSeparator);
    }
    return val;
  };
  const emitValue = (value) => {
    emit("update:modelValue", value);
  };
  const getRangeEmitValue = () => {
    return [
      getModelValueType(internalModelValue.value[0]),
      internalModelValue.value[1] ? getModelValueType(internalModelValue.value[1]) : null
    ];
  };
  const emitModelValue = () => {
    if (monthPicker) {
      emitValue(getMonthValForExternal(internalModelValue.value));
    } else if (timePicker) {
      emitValue(getTImeForExternal(internalModelValue.value));
    } else if (weekPicker) {
      emitValue(internalModelValue.value);
    } else if (yearPicker) {
      emitValue(Array.isArray(internalModelValue.value) ? [
        getYear(internalModelValue.value[0]),
        internalModelValue.value[1] ? getYear(internalModelValue.value[1]) : null
      ] : getYear(internalModelValue.value));
    } else {
      if (internalModelValue.value && range && partialRange && internalModelValue.value.length === 1) {
        internalModelValue.value.push(null);
      }
      if (utc) {
        let zonedDate;
        if (Array.isArray(internalModelValue.value)) {
          const mapDate = (date) => date ? dateToUtc(date, utc === "preserve") : date;
          if (modelAuto) {
            zonedDate = internalModelValue.value[1] ? internalModelValue.value.map(mapDate) : dateToUtc(internalModelValue.value[0], utc === "preserve");
          } else {
            zonedDate = internalModelValue.value.map(mapDate);
          }
        } else {
          zonedDate = dateToUtc(internalModelValue.value, utc === "preserve");
        }
        return emitValue(zonedDate);
      }
      if (Array.isArray(internalModelValue.value) && !multiDates) {
        if (modelAuto) {
          emitValue(internalModelValue.value[1] ? getRangeEmitValue() : getModelValueType(internalModelValue.value[0]));
        } else {
          emitValue(getRangeEmitValue());
        }
      } else if (Array.isArray(internalModelValue.value) && multiDates) {
        emitValue(internalModelValue.value.map((date) => getModelValueType(date)));
      } else {
        emitValue(getModelValueType(internalModelValue.value));
      }
    }
    formatInputValue();
  };
  return {
    parseExternalModelValue,
    formatInputValue,
    internalModelValue,
    inputValue,
    emitModelValue,
    checkBeforeEmit
  };
};
const defaultWindow = typeof window !== "undefined" ? window : void 0;
const noop = () => {
  return;
};
const tryOnScopeDispose = (fn) => {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
};
const useEventListener = (target, event, listener, options) => {
  if (!target)
    return noop;
  let cleanup = noop;
  const stopWatch = watch(() => unref(target), (el) => {
    cleanup();
    if (!el)
      return;
    el.addEventListener(event, listener, options);
    cleanup = () => {
      el.removeEventListener(event, listener, options);
      cleanup = noop;
    };
  }, { immediate: true, flush: "post" });
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return stop;
};
const onClickOutside = (target, inputRef, handler, options = {}) => {
  const { window: window2 = defaultWindow, event = "pointerdown" } = options;
  if (!window2)
    return;
  const listener = (event2) => {
    const el = unrefElement(target);
    const inputEl = unrefElement(inputRef);
    if (!el || !inputEl)
      return;
    if (el === event2.target || event2.composedPath().includes(el) || event2.composedPath().includes(inputEl))
      return;
    handler(event2);
  };
  return useEventListener(window2, event, listener, { passive: true });
};
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "VueDatePicker",
  props: {
    ...AllProps
  },
  emits: [
    "update:modelValue",
    "textSubmit",
    "closed",
    "cleared",
    "open",
    "focus",
    "blur",
    "internalModelChange",
    "recalculatePosition",
    "flow-step",
    "updateMonthYear",
    "invalid-select"
  ],
  setup(__props, { expose, emit }) {
    const props = __props;
    const slots2 = useSlots();
    const isOpen = ref(false);
    const modelValueMap = toRef(props, "modelValue");
    const dpMenuRef = ref(null);
    const inputRef = ref(null);
    provide(autoApplyKey, props.autoApply);
    const formatLocaleRef = computed(() => props.formatLocale);
    provide(formatLocaleKey, formatLocaleRef);
    provide(textInputKey, toRef(props, "textInput"));
    provide(arrowNavigationKey, toRef(props, "arrowNavigation"));
    onMounted(() => {
      parseExternalModelValue(props.modelValue);
      if (!props.inline) {
        window.addEventListener("scroll", onScroll);
        window.addEventListener("resize", onResize);
      }
      if (props.inline) {
        isOpen.value = true;
      }
    });
    onUnmounted(() => {
      if (!props.inline) {
        window.removeEventListener("scroll", onScroll);
        window.removeEventListener("resize", onResize);
      }
    });
    const slotList = mapSlots(slots2, "all");
    const inputSlots2 = mapSlots(slots2, "input");
    watch(modelValueMap, () => {
      parseExternalModelValue(modelValueMap.value);
    }, { deep: true });
    const { openOnTop, menuPosition, setMenuPosition, recalculatePosition, setInitialPosition } = usePosition(props.position, props.altPosition, props.autoPosition, dpMenuRef, inputRef, props.inline, emit);
    const {
      internalModelValue,
      inputValue,
      parseExternalModelValue,
      emitModelValue,
      checkBeforeEmit,
      formatInputValue
    } = useExternalInternalMapper(props.format, props.timePicker, props.monthPicker, props.range, props.partialRange, props.is24, props.enableTimePicker, props.enableSeconds, formatLocaleRef, props.multiDates, props.utc, props.weekPicker, props.yearPicker, props.textInputOptions, props.modelType, props.modelAuto, emit);
    const { clearArrowNav } = useArrowNavigation();
    const { setMenuFocused, setShiftKey } = useStore();
    const wrapperClass = computed(() => ({
      dp__main: true,
      dp__theme_dark: props.dark,
      dp__theme_light: !props.dark,
      dp__flex_display: props.inline,
      dp__flex_display_with_input: props.inlineWithInput
    }));
    const defaultPattern = computed(() => {
      return isString(props.format) ? props.format : getDefaultPattern(null, props.is24, props.enableSeconds, props.monthPicker, props.timePicker, props.weekPicker, props.yearPicker, props.enableTimePicker);
    });
    const previewFormatDefault = computed(() => {
      if (!props.previewFormat) {
        return isString(defaultPattern.value) ? defaultPattern.value : props.format;
      }
      return props.previewFormat;
    });
    const defaultTransitions = computed(() => {
      if (typeof props.transitions === "boolean") {
        return props.transitions ? mergeDefaultTransitions({}) : false;
      }
      return mergeDefaultTransitions(props.transitions);
    });
    provide(transitionsKey, defaultTransitions);
    const theme = computed(() => props.dark ? "dp__theme_dark" : "dp__theme_light");
    const inputDefaultOptions = computed(() => {
      return Object.assign(getDefaultTextInputOptions(), props.textInputOptions);
    });
    const areaLabelsDefault = computed(() => defaultAriaLabels(props.ariaLabels));
    provide(ariaLabelsKey, areaLabelsDefault);
    const defaultFilters = computed(() => getDefaultFilters(props.filters));
    const defaultStartTime = computed(() => {
      const assignDefaultTime = (obj) => {
        const defaultTime = {
          hours: getHours(new Date()),
          minutes: getMinutes(new Date()),
          seconds: getSeconds(new Date())
        };
        return Object.assign(defaultTime, obj);
      };
      if (props.range) {
        if (props.startTime && Array.isArray(props.startTime)) {
          return [assignDefaultTime(props.startTime[0]), assignDefaultTime(props.startTime[1])];
        }
        return null;
      }
      return props.startTime && !Array.isArray(props.startTime) ? assignDefaultTime(props.startTime) : null;
    });
    const multiCalendarDefault = computed(() => {
      if (props.multiCalendars === null)
        return 0;
      if (typeof props.multiCalendars === "boolean")
        return props.multiCalendars ? 2 : 0;
      return +props.multiCalendars >= 2 ? +props.multiCalendars : 2;
    });
    const onScroll = () => {
      if (isOpen.value) {
        if (props.closeOnScroll) {
          closeMenu();
        } else if (props.autoPosition) {
          setMenuPosition();
        } else {
          window.removeEventListener("scroll", onScroll);
        }
      }
    };
    const onResize = () => {
      if (isOpen.value) {
        setMenuPosition();
      }
    };
    const openMenu = () => {
      if (!props.disabled && !props.readonly) {
        setInitialPosition();
        isOpen.value = true;
        nextTick().then(() => {
          setMenuPosition();
          if (isOpen.value) {
            emit("open");
          }
        });
        if (!isOpen.value) {
          clearInternalValues();
        }
        parseExternalModelValue(props.modelValue);
      }
    };
    const clearValue = () => {
      inputValue.value = "";
      clearInternalValues();
      emit("update:modelValue", null);
      emit("cleared");
      closeMenu();
    };
    const validateBeforeEmit = () => {
      const { validate } = dateValidator(props.minDate, props.maxDate, props.disabledDates, props.allowedDates, defaultFilters.value, props.disabledWeekDays, props.yearRange);
      const date = internalModelValue.value;
      if (!date)
        return true;
      if (!Array.isArray(date) && validate(date)) {
        return true;
      }
      if (Array.isArray(date)) {
        if (date.length === 2 && validate(date[0]) && validate(date[1])) {
          return true;
        } else if (validate(date[0])) {
          return true;
        }
        return false;
      }
      return false;
    };
    const selectDate = () => {
      if (checkBeforeEmit() && validateBeforeEmit()) {
        emitModelValue();
        closeMenu();
      } else {
        emit("invalid-select", internalModelValue.value);
      }
    };
    const emitOnAutoApply = (ignoreClose) => {
      emitModelValue();
      if (props.closeOnAutoApply && !ignoreClose) {
        closeMenu();
      }
    };
    const autoApplyValue = (ignoreClose = false) => {
      if (props.autoApply) {
        const isTimeValid = !props.enableTimePicker || props.monthPicker || props.yearPicker ? true : isValidTime(internalModelValue.value, props.maxTime, props.minTime, props.maxDate, props.minDate);
        if (isTimeValid && validateBeforeEmit()) {
          if (props.range && Array.isArray(internalModelValue.value)) {
            if (props.partialRange) {
              emitOnAutoApply(ignoreClose);
            } else if (internalModelValue.value.length === 2) {
              emitOnAutoApply(ignoreClose);
            }
          } else {
            emitOnAutoApply(ignoreClose);
          }
        }
      }
    };
    const clearInternalValues = () => {
      internalModelValue.value = null;
    };
    const closeMenu = () => {
      if (!props.inline) {
        if (isOpen.value) {
          isOpen.value = false;
          setMenuFocused(false);
          setShiftKey(false);
          clearArrowNav();
          emit("closed");
          setInitialPosition();
          if (inputValue.value) {
            parseExternalModelValue(modelValueMap.value);
          }
        }
        clearInternalValues();
        if (inputRef.value) {
          inputRef.value.focusInput();
        }
      }
    };
    const setInputDate = (date, submit) => {
      if (!date) {
        internalModelValue.value = null;
        return;
      }
      internalModelValue.value = date;
      if (submit) {
        selectDate();
        emit("textSubmit");
      }
    };
    const timeUpdate = () => {
      if (props.autoApply && isValidTime(internalModelValue.value, props.maxTime, props.minTime, props.maxDate, props.minDate)) {
        emitModelValue();
      }
    };
    const toggleMenu = () => {
      if (isOpen.value)
        return closeMenu();
      return openMenu();
    };
    onClickOutside(dpMenuRef, inputRef, closeMenu);
    expose({
      closeMenu,
      selectDate,
      clearValue,
      openMenu,
      onScroll,
      formatInputValue
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(unref(wrapperClass))
      }, [
        createVNode(_sfc_main$a, mergeProps({
          ref_key: "inputRef",
          ref: inputRef
        }, {
          placeholder: _ctx.placeholder,
          hideInputIcon: _ctx.hideInputIcon,
          readonly: _ctx.readonly,
          disabled: _ctx.disabled,
          inputClassName: _ctx.inputClassName,
          clearable: _ctx.clearable,
          state: _ctx.state,
          inline: _ctx.inline,
          inlineWithInput: _ctx.inlineWithInput,
          textInput: _ctx.textInput,
          textInputOptions: unref(inputDefaultOptions),
          range: _ctx.range,
          isMenuOpen: isOpen.value,
          pattern: unref(defaultPattern),
          autoApply: _ctx.autoApply,
          uid: _ctx.uid,
          required: _ctx.required,
          name: _ctx.name,
          autocomplete: _ctx.autocomplete
        }, {
          "input-value": unref(inputValue),
          "onUpdate:input-value": _cache[0] || (_cache[0] = ($event) => isRef(inputValue) ? inputValue.value = $event : null),
          onClear: clearValue,
          onOpen: openMenu,
          onSetInputDate: setInputDate,
          onSetEmptyDate: unref(emitModelValue),
          onSelectDate: selectDate,
          onToggle: toggleMenu,
          onClose: closeMenu,
          onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("focus")),
          onBlur: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("blur"))
        }), createSlots({ _: 2 }, [
          renderList(unref(inputSlots2), (slot, i) => {
            return {
              name: slot,
              fn: withCtx((args) => [
                renderSlot(_ctx.$slots, slot, normalizeProps(guardReactiveProps(args)))
              ])
            };
          })
        ]), 1040, ["input-value", "onSetEmptyDate"]),
        isOpen.value ? (openBlock(), createBlock(Teleport, {
          key: 0,
          to: _ctx.teleport,
          disabled: _ctx.inline
        }, [
          isOpen.value ? (openBlock(), createBlock(_sfc_main$1, mergeProps({
            key: 0,
            ref_key: "dpMenuRef",
            ref: dpMenuRef,
            class: unref(theme),
            style: unref(menuPosition)
          }, {
            weekNumbers: _ctx.weekNumbers,
            weekStart: _ctx.weekStart,
            disableMonthYearSelect: _ctx.disableMonthYearSelect,
            menuClassName: _ctx.menuClassName,
            calendarClassName: _ctx.calendarClassName,
            yearRange: _ctx.yearRange,
            range: _ctx.range,
            multiCalendars: unref(multiCalendarDefault),
            multiCalendarsSolo: _ctx.multiCalendarsSolo,
            multiStatic: _ctx.multiStatic,
            calendarCellClassName: _ctx.calendarCellClassName,
            enableTimePicker: _ctx.enableTimePicker,
            is24: _ctx.is24,
            hoursIncrement: _ctx.hoursIncrement,
            minutesIncrement: _ctx.minutesIncrement,
            hoursGridIncrement: _ctx.hoursGridIncrement,
            minutesGridIncrement: _ctx.minutesGridIncrement,
            minDate: _ctx.minDate,
            maxDate: _ctx.maxDate,
            autoApply: _ctx.autoApply,
            selectText: _ctx.selectText,
            cancelText: _ctx.cancelText,
            previewFormat: unref(previewFormatDefault),
            locale: _ctx.locale,
            weekNumName: _ctx.weekNumName,
            disabledDates: _ctx.disabledDates,
            filters: unref(defaultFilters),
            minTime: _ctx.minTime,
            maxTime: _ctx.maxTime,
            inline: _ctx.inline,
            openOnTop: unref(openOnTop),
            monthPicker: _ctx.monthPicker,
            timePicker: _ctx.timePicker,
            monthNameFormat: _ctx.monthNameFormat,
            startDate: _ctx.startDate,
            startTime: unref(defaultStartTime),
            monthYearComponent: _ctx.monthYearComponent,
            timePickerComponent: _ctx.timePickerComponent,
            actionRowComponent: _ctx.actionRowComponent,
            customProps: _ctx.customProps,
            hideOffsetDates: _ctx.hideOffsetDates,
            autoRange: _ctx.autoRange,
            noToday: _ctx.noToday,
            noHoursOverlay: _ctx.noHoursOverlay,
            noMinutesOverlay: _ctx.noMinutesOverlay,
            disabledWeekDays: _ctx.disabledWeekDays,
            allowedDates: _ctx.allowedDates,
            showNowButton: _ctx.showNowButton,
            nowButtonLabel: _ctx.nowButtonLabel,
            monthChangeOnScroll: _ctx.monthChangeOnScroll,
            markers: _ctx.markers,
            uid: _ctx.uid,
            modeHeight: _ctx.modeHeight,
            enableSeconds: _ctx.enableSeconds,
            secondsIncrement: _ctx.secondsIncrement,
            secondsGridIncrement: _ctx.secondsGridIncrement,
            noSecondsOverlay: _ctx.noSecondsOverlay,
            escClose: _ctx.escClose,
            spaceConfirm: _ctx.spaceConfirm,
            monthChangeOnArrows: _ctx.monthChangeOnArrows,
            textInput: _ctx.textInput,
            disabled: _ctx.disabled,
            readonly: _ctx.readonly,
            multiDates: _ctx.multiDates,
            presetRanges: _ctx.presetRanges,
            flow: _ctx.flow,
            preventMinMaxNavigation: _ctx.preventMinMaxNavigation,
            minRange: _ctx.minRange,
            maxRange: _ctx.maxRange,
            fixedStart: _ctx.fixedStart,
            fixedEnd: _ctx.fixedEnd,
            multiDatesLimit: _ctx.multiDatesLimit,
            reverseYears: _ctx.reverseYears,
            keepActionRow: _ctx.keepActionRow,
            weekPicker: _ctx.weekPicker,
            noSwipe: _ctx.noSwipe,
            vertical: _ctx.vertical,
            arrowNavigation: _ctx.arrowNavigation,
            yearPicker: _ctx.yearPicker,
            disableTimeRangeValidation: _ctx.disableTimeRangeValidation,
            dayNames: _ctx.dayNames,
            modelAuto: _ctx.modelAuto,
            highlight: _ctx.highlight,
            partialRange: _ctx.partialRange
          }, {
            internalModelValue: unref(internalModelValue),
            "onUpdate:internalModelValue": _cache[3] || (_cache[3] = ($event) => isRef(internalModelValue) ? internalModelValue.value = $event : null),
            onClosePicker: closeMenu,
            onSelectDate: selectDate,
            onDpOpen: unref(recalculatePosition),
            onAutoApply: autoApplyValue,
            onTimeUpdate: timeUpdate,
            onFlowStep: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("flow-step", $event)),
            onUpdateMonthYear: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("updateMonthYear", $event))
          }), createSlots({ _: 2 }, [
            renderList(unref(slotList), (slot, i) => {
              return {
                name: slot,
                fn: withCtx((args) => [
                  renderSlot(_ctx.$slots, slot, normalizeProps(guardReactiveProps({ ...args })))
                ])
              };
            })
          ]), 1040, ["class", "style", "internalModelValue", "onDpOpen"])) : createCommentVNode("", true)
        ], 8, ["to", "disabled"])) : createCommentVNode("", true)
      ], 2);
    };
  }
});
const component = /* @__PURE__ */ (() => {
  const installable = _sfc_main;
  installable.install = (app) => {
    app.component("Vue3DatePicker", installable);
  };
  return installable;
})();
const namedExports = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: component
}, Symbol.toStringTag, { value: "Module" }));
Object.entries(namedExports).forEach(([exportName, exported]) => {
  if (exportName !== "default")
    component[exportName] = exported;
});
export {
  component as default
};
